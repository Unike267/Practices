
\chapter{Código} % Título del Anexo

\label{Codigo} % Etiqueta \ref{Planos}

El código empleado a lo largo de este trabajo es bastante extenso.
Comprende desde la descripción hardware en VHDL de los diseños y los \textit{test benches}, pasando por la codificación de software en C, archivos en Python para lanzar las simulaciones de VUnit, así como para gestionar sus archivos de salida en formato csv, además de archivos Yml para gestionar la integración continua, archivos Bash para gestionar la generación de \textit{bitstream} mediante herramientas FLOS y archivos Tcl para gestionar la generación de \textit{bitstream} mediante Vivado. 
El total del código empleado está en el repositorio de GitLab del grupo de investigación y gran parte de él, sobre todo el referente a la sección \ref{Carac}, está en el siguiente repositorio público de GitHub \cite{gh:practices}.
Este apéndice comprende parte del código desarrollado como ejemplificación del trabajo realizado a lo largo de este proyecto de investigación.

%\begin{code}
%\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}

%\end{minted}
%\caption{}
%\label{ap-cod:}
%\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,linenos]{vhdl}
-- RTL of MULT

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity mult is
generic (  
        -- Number of bits that the input/output data has. 
        N_bits : in natural
        );
port (
        -- Clock signal
        clk : in std_logic;
        -- Mult in/out signals
        mult_in : in std_logic_vector (N_bits-1 downto 0);
        mult_out : out std_logic_vector(N_bits-1 downto 0)
     );
end mult;

architecture rtl of mult is

-- Declaration of signals

signal in_1 : unsigned ((N_bits/2)-1 downto 0) := (others => '0');
signal in_2 : unsigned ((N_bits/2)-1 downto 0) := (others => '0');

begin
  
    -- Assign inputs to the multipler 

    in_1 <= unsigned(mult_in(N_bits-1 downto N_bits/2));
    in_2 <= unsigned(mult_in((N_bits/2)-1 downto 0));

    -- Make multiplication and assign output

    mult_make : process ( clk )
        begin
            if( rising_edge (clk) ) then
                mult_out <= std_logic_vector(in_1 * in_2);
            end if;
    end process mult_make;

end rtl;
\end{minted}
\caption{Mult.vhd}
\label{ap-cod:1}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- RTL of FIFO

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity fifo is
generic (  
        -- Number of bits per element 
        N_bits : in natural;
        -- Log2 of number of elements that the FIFO has; Number of FIFO elements has to be a power of two.
        Log2_elements : in natural
        );
port (
        -- Fifo clocks/reset signals        
        clk_wr : in std_logic;
        clk_rd : in std_logic;
        rst : in std_logic;
        -- Fifo in/out signals
        fifo_in : in std_logic_vector (N_bits-1 downto 0);
        fifo_out : out std_logic_vector(N_bits-1 downto 0);
        -- Fifo write/read signals
        wr : in std_logic;
        rd : in std_logic;
        -- Fifo status signals
        full_o : out std_logic;
        empty_o : out std_logic
     );
end fifo;

architecture rtl of fifo is

-- Declariation of fifo array

type array_type is array ((2**Log2_elements)-1 downto 0) of std_logic_vector(N_bits-1 downto 0);
signal fifo_array : array_type := (others => (others => '0'));

-- Declaration of signals

signal wr_pnt : std_logic_vector(Log2_elements downto 0) := (others => '0');
signal rd_pnt : std_logic_vector(Log2_elements downto 0) := (others => '0');
signal full : std_logic := '0';
signal empty : std_logic := '0';


begin

    -- Signals empty and full logic
    
    full_logic : process ( wr_pnt,rd_pnt )
    begin   
        if( (wr_pnt(Log2_elements-1 downto 0) = rd_pnt(Log2_elements-1 downto 0)) and ( (wr_pnt(wr_pnt'left) xor rd_pnt(rd_pnt'left)) = '1') ) then
            full <= '1';
        else
            full <= '0';
        end if;
    end process full_logic;    

    empty_logic : process ( wr_pnt,rd_pnt )  
    begin
        if ( wr_pnt = rd_pnt ) then
            empty <= '1';
        else
            empty <= '0';
        end if;
    end process empty_logic;

    -- Assign control signals output

    full_o <= full;
    empty_o <= empty;

    -- Write and read process

    write_process: process (clk_wr)
    begin
        if( rising_edge( clk_wr ) ) then
            if( rst = '1' ) then
                wr_pnt <= (others => '0');
            elsif( wr = '1' and full = '0' ) then
                fifo_array(to_integer(unsigned(wr_pnt(Log2_elements-1 downto 0)))) <= fifo_in;
                wr_pnt <= std_logic_vector(unsigned(wr_pnt) + 1);
            end if;                 
        end if;
    end process write_process;

    read_process: process (clk_rd)
    begin
        if( rising_edge( clk_rd ) ) then
            if( rst = '1' ) then
                rd_pnt <= (others => '0');
                fifo_out <= (others => '0');
            elsif( rd = '1' and empty = '0' ) then
                fifo_out <= fifo_array(to_integer(unsigned(rd_pnt(Log2_elements-1 downto 0))));
                rd_pnt <= std_logic_vector(unsigned(rd_pnt) + 1);
            end if;                 
        end if;
    end process read_process;

end rtl;
\end{minted}
\caption{fifo.vhd}
\label{ap-cod:2}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- RTL of Mult_wfifos

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity mult_wfifos is
generic (
        -- Number of bits that the input/output data has
        N_bits : in natural;
        -- Log2 of number of elements that the FIFOs have; Both the same size; Number of FIFO elements has to be a power of two
        Log2_elements : in natural
        );
port (
        -- Mult_wfifos clocks and reset signals
        clk_wr : in std_logic;
        clk_mult : in std_logic;
        clk_rd : in std_logic;
        rst : in std_logic;
        -- Mult_wfifos input/output data
        din : in std_logic_vector (N_bits-1 downto 0);
        dout : out std_logic_vector (N_bits-1 downto 0);
        -- Mult_wfifos write and read signals;
        wr : in std_logic;
        rd : in std_logic;
        -- Mult_wfifos status signals
        full : out std_logic;
        empty : out std_logic
);
end mult_wfifos;

architecture rtl of mult_wfifos is

-- Declaration of signals
signal in_pre_mult : std_logic_vector(N_bits-1 downto 0) := (others => '0');
signal in_post_mult : std_logic_vector(N_bits-1 downto 0) := (others => '0');
signal rd_inter : std_logic := '0';
signal wr_inter : std_logic := '0';
signal empty_inter : std_logic := '0';
signal full_inter : std_logic := '0';

type t_states is (CHECK,READ,MULTI,WRITE);
signal state : t_states := CHECK;
signal next_state : t_states;


begin

-- Fifo IN instantiation

fifo_IN : entity work.fifo
                generic map (N_bits => N_bits,
                             Log2_elements => Log2_elements)
                port map (clk_wr => clk_wr,
                          clk_rd => clk_mult,
                          rst => rst,
                          fifo_in => din,
                          fifo_out => in_pre_mult,
                          wr => wr,
                          rd => rd_inter,
                          full_o => full,
                          empty_o => empty_inter);

-- mult instantiation

mult_0 : entity  work.mult
                generic map (N_bits => N_bits)
                port map (clk => clk_mult,
                          mult_in => in_pre_mult,
                          mult_out => in_post_mult);

-- Fifo OUT instantiation

fifo_OUT : entity work.fifo
                generic map (N_bits => N_bits,
                             Log2_elements => Log2_elements)
                port map (clk_wr => clk_mult,
                          clk_rd => clk_rd,
                          rst => rst,
                          fifo_in => in_post_mult,
                          fifo_out => dout,
                          wr => wr_inter,
                          rd => rd,
                          full_o => full_inter,
                          empty_o => empty);

-- State machine
    -- Combinational

    Combinational_of_state_machine : process (state, empty_inter, full_inter)
    begin
        next_state <= state;
        case state is
            when CHECK =>
                if (empty_inter = '0' and full_inter = '0') then
                    next_state <= READ;
                else
                    next_state <= CHECK;
                end if;
            when READ =>
                next_state <= MULTI;
            when MULTI =>
                next_state <= WRITE;
            when WRITE =>
                next_state <= CHECK;
            when others =>
                next_state <= CHECK;
        end case;
    end process Combinational_of_state_machine;

    -- Outputs

    with state select
        wr_inter <= '1' when WRITE,
                    '0' when others;
    with state select
        rd_inter <= '1' when READ,
                    '0' when others;

    -- Sequential

    state_machine_state_reg : process ( clk_mult )
    begin
        if( rising_edge(clk_mult) ) then
            if( rst = '1' ) then
                state <= CHECK;
            else
                state <= next_state;
            end if;
        end if;
    end process state_machine_state_reg;

end rtl;
\end{minted}
\caption{Mult\_wfifos.vhd}
\label{ap-cod:3}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- RTL of mult_axis

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity mult_wfifos_axis is
generic (
        -- Number of bits that the input/output data has
        N_bits : in natural;
        -- Log2 of number of elements that the FIFOs have; Both the same size; Number of FIFO elements has to be a power of two
        Log2_elements : in natural
        );
port (
    -- Clk mult
    clk_mult : in std_logic;

    -- Slave signals
    s_axis_clk   : in  std_logic;
    s_axis_rstn  : in  std_logic;
    s_axis_rdy   : out std_logic;
    s_axis_data  : in  std_logic_vector(N_bits-1 downto 0);
    s_axis_valid : in  std_logic;

    -- Master signals
    m_axis_clk   : in  std_logic;
    m_axis_rstn  : in  std_logic;
    m_axis_valid : out std_logic;
    m_axis_data  : out std_logic_vector(N_bits-1 downto 0);
    m_axis_rdy   : in  std_logic
    );
end mult_wfifos_axis;

architecture rtl of mult_wfifos_axis is

signal reset, write, read, valid, empty, full : std_logic;

begin

-- Mult_wfifos instantation

mult_wfifos_0 : entity work.mult_wfifos
                generic map (N_bits => N_bits,
                             Log2_elements => Log2_elements)
                port map (clk_wr => s_axis_clk,
                          clk_mult => clk_mult,
                          clk_rd => m_axis_clk,
                          rst => reset,
                          din => s_axis_data,
                          dout => m_axis_data,
                          wr => write,
                          rd => read,
                          full => full,
                          empty => empty);

-- Reset (NEORV32 rst is low-active)

reset <= (s_axis_rstn nand m_axis_rstn);

-- Write and read signals

write <= s_axis_valid and not(full);

read <= not(empty) and (valid nand not(m_axis_rdy));

-- Make valid signal

make_valid : process(m_axis_clk) begin
    if rising_edge(m_axis_clk) then
        if (((not m_axis_rstn) or ((valid and empty) and m_axis_rdy)) = '1') then
            valid <= '0';
        elsif (read = '1') then
            valid <= '1';
        end if;
    end if;
    end process make_valid;

-- Assing axi signals

s_axis_rdy <= not(full);
m_axis_valid <= valid;

end rtl;
\end{minted}
\caption{mult\_wfifos\_axis.vhd}
\label{ap-cod:4}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- RTL of mult_wfifos_wishbone

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity mult_wfifos_wishbone is
generic (  
        -- Number of bits that the input/output data has
        N_bits : in natural;
        -- Log2 of number of elements that the FIFOs have; Both the same size; Number of FIFO elements has to be a power of two
        Log2_elements : in natural
        );
port (
    rst_i : in std_logic;
    clk_i : in std_logic;
    adr_i : in std_logic_vector(31 downto 0);
    dat_i : in std_logic_vector(31 downto 0);
    dat_o : out std_logic_vector(31 downto 0);
    we_i : in std_logic;
    sel_i : in std_logic_vector(3 downto 0);
    stb_i : in std_logic;
    ack_o : out std_logic;
    cyc_i : in std_logic;
    err_o : out std_logic;
    stall_o : out std_logic
    );
end mult_wfifos_wishbone;

architecture rtl of mult_wfifos_wishbone is

signal reset, write, read, empty, full : std_logic;
signal ack : std_logic;
signal stall : std_logic;
signal input : std_logic_vector(31 downto 0);
signal output : std_logic_vector(31 downto 0);
signal transfer_in : std_logic;
signal transfer_out : std_logic;
signal output_window : std_logic := '0';

begin

-- Mult_wfifos instantation

mult_wfifos_0 : entity work.mult_wfifos
                generic map (N_bits => N_bits,
                             Log2_elements => Log2_elements)
                port map (clk_wr => clk_i,
                          clk_mult => clk_i,
                          clk_rd => clk_i,
                          rst => reset,
                          din => input,
                          dout => output,
                          wr => write,
                          rd => read,
                          full => full,
                          empty => empty);

-- Reset (NEORV32 rst is low-active)

reset <= not rst_i;

-- Make error signal

err_o <= '0'; --tie to zero if not explicitly used

-- Make stall signal

with we_i select 
     stall <= full  when '1',
              empty when others;

stall_o <= stall;

-- Make transfer in/out signals

transfer_in  <= (stb_i and cyc_i and we_i and not(stall)) when adr_i = x"90000000" else  -- The address is 0x90000000; See main.c in sw/EMEM
                '0';

transfer_out <= (stb_i and cyc_i and not(we_i) and not(stall)) when adr_i = x"90000000" else
                '0';

-- Manage input/output and write/read signals

with transfer_in select
     input <= dat_i when '1',
              (others => '0') when others;

with transfer_in select
     write <= '1' when '1',
              '0' when others;

with transfer_out select
     read  <= '1' when '1',
              '0' when others;

with output_window select
     dat_o <= output when '1',
              (others => '0') when others;

-- Manage output_window

process (clk_i) begin
    if rising_edge(clk_i) then
      if reset = '1' then
        output_window <= '0';
      elsif transfer_out = '1' then
        output_window <= '1';
      else
        output_window <= '0';
      end if;
    end if;
end process;

-- Manage ack signal

process (clk_i) begin
    if rising_edge(clk_i) then
      if reset = '1' then
        ack <= '0';
      else
        if transfer_in or transfer_out then
          ack <= '1';
        else
          ack <= '0';
        end if;
      end if;
    end if;
  end process;
                
ack_o <= ack;

end rtl;
\end{minted}
\caption{mult\_wfifos\_wishbone.vhd}
\label{ap-cod:5}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- Authors:
--   Unai Martinez-Corral & Unai Sainz-Estebanez
--     <unai.martinezcorral@ehu.eus>
--     <usainz003@ikasle.ehu.eus>
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- SPDX-License-Identifier: Apache-2.0

library ieee;
context ieee.ieee_std_context;

entity multp_op is
  generic (
    g_data_width : natural
  );
  port (
    DIN : in std_logic_vector (g_data_width-1 downto 0);
    DOUT : out std_logic_vector(g_data_width-1 downto 0)
  );
end multp_op;

architecture arch of multp_op is
begin

  DOUT <= std_logic_vector(
    signed(DIN(g_data_width-1 downto g_data_width/2))
    *
    signed(DIN((g_data_width/2)-1 downto 0))
  );

end arch;


library ieee;
context ieee.ieee_std_context;

entity multp is
  generic (
    g_data_width : natural
  );
  port (
    CLK : in std_logic;
    RST : in std_logic;
    IN_VALID : in std_logic;
    IN_READY : out std_logic;
    DIN : in std_logic_vector (g_data_width-1 downto 0);
    OUT_VALID : out std_logic;
    OUT_READY : in std_logic;
    DOUT : out std_logic_vector(g_data_width-1 downto 0)
  );
end multp;

architecture registered of multp is

  signal ready: std_logic;
  signal valid : std_logic;
  signal transfer_in : std_logic;
  signal transfer_out : std_logic;
  signal result : std_logic_vector(g_data_width-1 downto 0);

begin

  transfer_in <= IN_VALID and ready;
  transfer_out <= valid and OUT_READY;
  ready <= not rst and ((not valid) or transfer_out);

  IN_READY <= ready;
  OUT_VALID <= valid;

  i_multp_op : entity work.multp_op
    generic map (
      g_data_width => g_data_width
    )
    port map (
      DIN  => DIN,
      DOUT => result
    );

  process (CLK) begin
    if rising_edge(CLK) then
      if RST then
        DOUT <= (others=>'0');
      elsif transfer_in then
        DOUT <= result;
      end if;
    end if;
  end process;

  process (CLK) begin
    if rising_edge(CLK) then
      if RST then
        valid <= '0';
      else
        if transfer_in then
          valid <= '1';
        elsif transfer_out then
          valid <= '0';
        end if;
      end if;
    end if;
  end process;

end registered;

architecture combinatorial of multp is

begin

  IN_READY <= OUT_READY;
  OUT_VALID <= IN_VALID;

  i_multp_op : entity work.multp_op
    generic map (
      g_data_width => g_data_width
    )
    port map (
      DIN  => DIN,
      DOUT => DOUT
    );

end combinatorial;
\end{minted}
\caption{multp.vhd}
\label{ap-cod:6}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- Authors:
--   Unai Martinez-Corral & Unai Sainz-Estebanez
--     <unai.martinezcorral@ehu.eus>
--     <usainz003@ikasle.ehu.eus>
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- SPDX-License-Identifier: Apache-2.0

library ieee;
context ieee.ieee_std_context;

entity multp_wfifos is
  generic (
    g_data_width : natural := 32;
    g_fifo_depth : natural := 0 -- ceiling of the log base 2 of the desired FIFO length
  );
  port (
     CLK_IN   : in std_logic;
     CLK_MULT : in std_logic;
     CLK_OUT  : in std_logic;
     RST      : in std_logic;
     DIN      : in std_logic_vector (g_data_width-1 downto 0);
     DOUT     : out std_logic_vector (g_data_width-1 downto 0);
     WRITE    : in std_logic;
     READ     : in std_logic;
     FULL     : out std_logic;
     EMPTY    : out std_logic
);
end multp_wfifos;

architecture rtl of multp_wfifos is

  signal data_in    : std_logic_vector(g_data_width-1 downto 0);
  signal data_out   : std_logic_vector(g_data_width-1 downto 0);
  signal i_read     : std_logic;
  signal i_write    : std_logic;
  signal i_empty    : std_logic;
  signal i_full     : std_logic;
  signal in_valid   : std_logic;
  signal in_ready   : std_logic;
  signal out_valid  : std_logic;
  signal out_ready  : std_logic;

begin

  fifo_in : entity work.fifo
    generic map (
      N_bits => g_data_width,
      Log2_elements => g_fifo_depth)
    port map (
      clk_wr => CLK_IN,
      clk_rd => CLK_MULT,
      rst => RST,
      fifo_in => DIN,
      fifo_out => data_in,
      wr => WRITE,
      rd => i_read,
      full_o => FULL,
      empty_o => i_empty
    );

  i_read <= in_ready and not i_empty;

  process (CLK_MULT) begin
    if rising_edge(CLK_MULT) then
      if RST then
        in_valid <= '0';
      else
        in_valid <= i_read;
      end if;
    end if;
  end process;

  multp : entity work.multp(combinatorial)
    generic map (
      g_data_width => g_data_width
    )
    port map (
      CLK => CLK_MULT,
      RST => RST,
      IN_VALID => in_valid,
      IN_READY => in_ready,
      DIN => data_in,
      OUT_VALID => out_valid,
      OUT_READY => out_ready,
      DOUT => data_out
    );

  i_write <= out_valid and out_ready;
  out_ready <= not i_full;

  fifo_out : entity work.fifo
    generic map (
      N_bits => g_data_width,
      Log2_elements => g_fifo_depth
    )
    port map (
      clk_wr => CLK_MULT,
      clk_rd => CLK_OUT,
      rst => RST,
      fifo_in => data_out,
      fifo_out => DOUT,
      wr => i_write,
      rd => READ,
      full_o => i_full,
      empty_o => EMPTY
    );

end rtl;
\end{minted}
\caption{multp\_wfifos.vhd}
\label{ap-cod:7}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- Authors:
--   Unai Martinez-Corral & Unai Sainz-Estebanez
--     <unai.martinezcorral@ehu.eus>
--     <usainz003@ikasle.ehu.eus>
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- SPDX-License-Identifier: Apache-2.0

library ieee;
context ieee.ieee_std_context;

entity multp_wfifos_axis is
  generic (
    g_data_width : natural := 32;
    g_fifo_depth : natural := 0 -- ceiling of the log base 2 of the desired FIFO length
  );
  port (
    CLK_MULT     : in std_logic;
    s_axis_clk   : in  std_logic;
    s_axis_rstn  : in  std_logic;
    s_axis_rdy   : out std_logic;
    s_axis_data  : in  std_logic_vector(g_data_width-1 downto 0);
    s_axis_valid : in  std_logic;
    m_axis_clk   : in  std_logic;
    m_axis_rstn  : in  std_logic;
    m_axis_valid : out std_logic;
    m_axis_data  : out std_logic_vector(g_data_width-1 downto 0);
    m_axis_rdy   : in  std_logic
  );
end multp_wfifos_axis;

architecture rtl of multp_wfifos_axis is

signal read, empty, full, valid : std_logic;

begin

  s_axis_rdy <= not full;

  i_multp_wfifos : entity work.multp_wfifos
    generic map (
      g_data_width => g_data_width,
      g_fifo_depth => g_fifo_depth
    )
    port map (
      CLK_IN   => s_axis_clk,
      CLK_MULT => clk_mult,
      CLK_OUT  => m_axis_clk,
      RST      => s_axis_rstn nand m_axis_rstn,
      DIN      => s_axis_data,
      DOUT     => m_axis_data,
      WRITE    => s_axis_valid and not full,
      READ     => read,
      FULL     => full,
      EMPTY    => empty
    );

  read <= (valid nand not m_axis_rdy) and not empty;

  process (m_axis_clk) begin
    if rising_edge(m_axis_clk) then
      if (not m_axis_rstn) or ((valid and empty) and m_axis_rdy) then
        valid <= '0';
      elsif read then
        valid <= '1';
      end if;
    end if;
  end process;

  m_axis_valid <= valid;

end rtl;
\end{minted}
\caption{multp\_wfifos\_axis.vhd}
\label{ap-cod:8}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- RTL of multp_wfifos_wishbone

library ieee;
context ieee.ieee_std_context;

entity multp_wfifos_wishbone is
generic (  
        -- Number of bits that the input/output data has
        N_bits : in natural;
        -- Log2 of number of elements that the FIFOs have; Both the same size; Number of FIFO elements has to be a power of two
        Log2_elements : in natural
        );
port (
    rst_i : in std_logic;
    clk_i : in std_logic;
    adr_i : in std_logic_vector(31 downto 0);
    dat_i : in std_logic_vector(31 downto 0);
    dat_o : out std_logic_vector(31 downto 0);
    we_i : in std_logic;
    sel_i : in std_logic_vector(3 downto 0);
    stb_i : in std_logic;
    ack_o : out std_logic;
    cyc_i : in std_logic;
    err_o : out std_logic;
    stall_o : out std_logic
    );
end multp_wfifos_wishbone;

architecture rtl of multp_wfifos_wishbone is

signal reset, write, read, empty, full : std_logic;
signal ack : std_logic;
signal stall : std_logic;
signal input : std_logic_vector(31 downto 0);
signal output : std_logic_vector(31 downto 0);
signal transfer_in : std_logic;
signal transfer_out : std_logic;
signal output_window : std_logic := '0';

begin

-- Multp_wfifos instantation

multp_wfifos_0 : entity work.multp_wfifos
                 generic map (g_data_width => N_bits,
                              g_fifo_depth => Log2_elements)
                 port map (clk_in => clk_i,
                           clk_mult => clk_i,
                           clk_out => clk_i,
                           rst => reset,
                           din => input,
                           dout => output,
                           write => write,
                           read => read,
                           full => full,
                           empty => empty);

-- Reset (NEORV32 rst is low-active)

reset <= not rst_i;

-- Make error signal

err_o <= '0'; --tie to zero if not explicitly used

-- Make stall signal

with we_i select 
     stall <= full  when '1',
              empty when others;

stall_o <= stall;

-- Make transfer in/out signals

transfer_in  <= (stb_i and cyc_i and we_i and not(stall)) when adr_i = x"90000000" else  -- The address is 0x90000000; See main.c in sw/EMEM
                '0';

transfer_out <= (stb_i and cyc_i and not(we_i) and not(stall)) when adr_i = x"90000000" else
                '0';

-- Manage input/output and write/read signals

with transfer_in select
     input <= dat_i when '1',
              (others => '0') when others;

with transfer_in select
     write <= '1' when '1',
              '0' when others;

with transfer_out select
     read  <= '1' when '1',
              '0' when others;

with output_window select
     dat_o <= output when '1',
              (others => '0') when others;

-- Manage output_window

process (clk_i) begin
    if rising_edge(clk_i) then
      if reset = '1' then
        output_window <= '0';
      elsif transfer_out = '1' then
        output_window <= '1';
      else
        output_window <= '0';
      end if;
    end if;
end process;

-- Manage ack signal

process (clk_i) begin
    if rising_edge(clk_i) then
      if reset = '1' then
        ack <= '0';
      else
        if transfer_in or transfer_out then
          ack <= '1';
        else
          ack <= '0';
        end if;
      end if;
    end if;
  end process;
                
ack_o <= ack;

end rtl;
\end{minted}
\caption{multp\_wfifos\_wishbone.vhd}
\label{ap-cod:9}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- RTL of multp

library ieee;
context ieee.ieee_std_context;

entity multp_wishbone is
generic (  
        -- Number of bits that the input/output data has
        N_bits : in natural
        );
port (
    rst_i : in std_logic;
    clk_i : in std_logic;
    adr_i : in std_logic_vector(31 downto 0);
    dat_i : in std_logic_vector(31 downto 0);
    dat_o : out std_logic_vector(31 downto 0);
    we_i : in std_logic;
    sel_i : in std_logic_vector(3 downto 0);
    stb_i : in std_logic;
    ack_o : out std_logic;
    cyc_i : in std_logic;
    err_o : out std_logic;
    stall_o : out std_logic
    );
end multp_wishbone;

architecture rtl of multp_wishbone is

signal reset : std_logic;
signal ack : std_logic;
signal input : std_logic_vector(31 downto 0);
signal output : std_logic_vector(31 downto 0);
signal transfer_in : std_logic;
signal transfer_out : std_logic;

begin

-- Multp instantation

multp_0 : entity work.multp_op
                 generic map (g_data_width => N_bits)
                 port map (din => input,
                           dout => output);

-- Reset (NEORV32 rst is low-active)

reset <= not rst_i;

-- Make error signal

err_o <= '0'; --tie to zero if not explicitly used

-- Make stall signal

stall_o <= '0';

-- Make transfer in/out signals

transfer_in  <= (stb_i and cyc_i and we_i) when adr_i = x"90000000" else -- The address is 0x90000000; See main.c in sw/EMEM
                '0';

transfer_out <= (stb_i and cyc_i and not(we_i)) when adr_i = x"90000000" else
                '0';

-- Manage inputs/outputs

process (clk_i) begin
    if rising_edge(clk_i) then
      if reset = '1' then
        input <= (others=>'0');
        dat_o <= (others=>'0');
      elsif transfer_in then
        input <= dat_i;
        dat_o <= (others=>'0');
      elsif transfer_out then
        dat_o <= output;
      else
        dat_o <= (others=>'0');
      end if;
    end if;
end process;

-- Make ack signal

process (clk_i) begin
    if rising_edge(clk_i) then
      if reset = '1' then
        ack <= '0';
      else
        if transfer_in or transfer_out then
          ack <= '1';
        else
          ack <= '0';
        end if;
      end if;
    end if;
  end process;

ack_o <= ack;

end rtl;
\end{minted}
\caption{multp\_wishbone.vhd}
\label{ap-cod:10}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{c}
#include <neorv32.h>
#include <string.h>

#define BAUD_RATE 19200

// This defines is used to bypass the intermediate print functions between axi functions (for latency and throughput measurements)
// Comment these defines to perform a normal execution
// Uncomment latency to perform latency measurements
// Uncomment throughput to perform throughput measurements
//#define latency
//#define throughput

int main() {

  // Capture all exceptions and give debug info via UART0
  neorv32_rte_setup();

  // Setup UART at default baud rate, no interrupts
  neorv32_uart0_setup(BAUD_RATE, 0);

  // Check if UART0 unit is implemented at all
  if (neorv32_uart0_available() == 0) {
    return -1; // abort if not implemented
  }

  // check if the CPU base counters are implemented
  if ((neorv32_cpu_csr_read(CSR_MXISA) & (1 << CSR_MXISA_ZICNTR)) == 0) {
    neorv32_uart0_printf("ERROR! Base counters ('Zicntr' ISA extensions) not implemented!\n");
    return -1;
  }

  // check if SLINK is implemented at all
  if (neorv32_slink_available() == 0) {
    neorv32_uart0_printf("ERROR! SLINK module not implemented.");
    return -1;
  }

  // setup SLINK module
  neorv32_slink_setup(0, 0);

  // Declaration of variables 
  //0000000000000001 x 0000000000000001
  static uint32_t fir = 0x00010001;
  //0000000000000010 x 0000000000000010
  static uint32_t sec = 0x00020002;
  //0000000000000100 x 0000000000000100
  static uint32_t thi = 0x00040004;
  //0000000000001000 x 0000000000001000
  static uint32_t fou = 0x00080008;

#ifdef latency
  // Intro
  neorv32_uart0_printf("\n A-lat \n\n");
  // Write 4 inputs to mult and read the outputs from mult one by one
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_slink_put(fir);
    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_slink_put(sec);
    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_slink_put(thi);
    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_slink_put(fou);
    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE); 

  // End
  neorv32_uart0_printf("\nEND-lat\n");
  #elif defined throughput
  // Intro
  neorv32_uart0_printf("\n A-thr \n\n");
  // Write 4 inputs to mult

    neorv32_slink_put(fir);

    neorv32_slink_put(sec);

    neorv32_slink_put(thi);

    neorv32_slink_put(fou);

  // Read outputs from mult

    neorv32_slink_get();
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);

    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE);

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE);

  // End
  neorv32_uart0_printf("\nEND-thr\n");
  #else
  int i, slink_rc;;
  // show SLINK FIFO configuration
  int rx_depth = neorv32_slink_get_rx_fifo_depth();
  int tx_depth = neorv32_slink_get_tx_fifo_depth();
  // Intro
  neorv32_uart0_printf("\n<<< MULT(P) via slink (AXI-Stream) demo program >>>\n\n");
  neorv32_uart0_printf("RX FIFO depth: %u\n"
                       "TX FIFO depth: %u\n\n",
                       rx_depth, tx_depth);
  neorv32_uart0_printf("-------- Write data to MULT(P) --------\n");
  // Write 4 inputs to mult
    for (i=0; i<4 ; i++) {
    if(i==0){
            neorv32_uart0_printf("[%i] Sending 0x%x... ", i, fir);
            slink_rc = neorv32_slink_tx_status();
                if (slink_rc == SLINK_FIFO_FULL) {
                        neorv32_uart0_printf("FAILED! TX FIFO full!\n");
                        break;
                }
                else {
                        neorv32_slink_put(fir);
                        neorv32_uart0_printf("ok\n");
                     }
            } 
    if(i==1){
            neorv32_uart0_printf("[%i] Sending 0x%x... ", i, sec);
            slink_rc = neorv32_slink_tx_status();
                if (slink_rc == SLINK_FIFO_FULL) {
                        neorv32_uart0_printf("FAILED! TX FIFO full!\n");
                        break;
                }
                else {
                        neorv32_slink_put(sec);
                        neorv32_uart0_printf("ok\n");
                     }
            }   
    if(i==2){
            neorv32_uart0_printf("[%i] Sending 0x%x... ", i, thi);
            slink_rc = neorv32_slink_tx_status();
                if (slink_rc == SLINK_FIFO_FULL) {
                        neorv32_uart0_printf("FAILED! TX FIFO full!\n");
                        break;
                }
                else {
                        neorv32_slink_put(thi);
                        neorv32_uart0_printf("ok\n");
                     }
            }   
    if(i==3){
            neorv32_uart0_printf("[%i] Sending 0x%x... ", i, fou);
            slink_rc = neorv32_slink_tx_status();
                if (slink_rc == SLINK_FIFO_FULL) {
                        neorv32_uart0_printf("FAILED! TX FIFO full!\n");
                        break;
                }
                else {
                        neorv32_slink_put(fou);
                        neorv32_uart0_printf("ok\n");
                     }
            }   
    } 
  neorv32_uart0_printf("\n-------- Read data from MULT(P) --------\n");
  // Read outputs from mult
    for (i=0; i<4; i++) {
            neorv32_uart0_printf("[%i] Reading RX data... ", i);
            slink_rc = neorv32_slink_rx_status();
                if (slink_rc == SLINK_FIFO_EMPTY) {
                    neorv32_uart0_printf("FAILED! RX FIFO empty!\n");
                    break;
                }
                else {  
                    neorv32_uart0_printf("0x%x\n", neorv32_slink_get());
                }
    }
  // End
  neorv32_uart0_printf("\nProgram execution completed.\n");
  #endif

  return 0;
}
\end{minted}
\caption{SLINK main.c}
\label{ap-cod:11}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{c}
#include <neorv32.h>
#include <string.h>

#define BAUD_RATE 19200

// This defines is used to bypass the intermediate print functions between wishbone functions (for latency and throughput measurements)
// Comment these defines to perform a normal execution
// Uncomment latency to perform latency measurements
// Uncomment throughput to perform throughput measurements
//#define latency
//#define throughput

int main() {
    
  // Capture all exceptions and give debug info via UART0
  neorv32_rte_setup();

  // Setup UART at default baud rate, no interrupts
  neorv32_uart0_setup(BAUD_RATE, 0);

  // Check if UART0 unit is implemented at all
  if (neorv32_uart0_available() == 0) {
    return -1; // abort if not implemented
  }

  // check if the CPU base counters are implemented
  if ((neorv32_cpu_csr_read(CSR_MXISA) & (1 << CSR_MXISA_ZICNTR)) == 0) {
    neorv32_uart0_printf("ERROR! Base counters ('Zicntr' ISA extensions) not implemented!\n");
    return -1;
  }

  // Declaration of variables 
  // address 0x90000000
  static uint32_t add = 0x90000000;
  //0000000000000001 x 0000000000000001
  static uint32_t fir = 0x00010001;
  //0000000000000010 x 0000000000000010
  static uint32_t sec = 0x00020002;
  //0000000000000100 x 0000000000000100
  static uint32_t thi = 0x00040004;
  //0000000000001000 x 0000000000001000
  static uint32_t fou = 0x00080008;

  #ifdef latency
  // Intro
  neorv32_uart0_printf("\n W-lat \n\n");
  // Write 4 inputs to mult and read the outputs from mult one by one
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cpu_store_unsigned_word(add, fir);
    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cpu_store_unsigned_word(add, sec);
    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cpu_store_unsigned_word(add, thi);
    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cpu_store_unsigned_word(add, fou);
    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE); 

  // End
  neorv32_uart0_printf("\nEND-lat\n");
  #elif defined throughput
  // Intro
  neorv32_uart0_printf("\n W-thr \n\n");
  // Write 4 inputs to mult

    neorv32_cpu_store_unsigned_word(add, fir);

    neorv32_cpu_store_unsigned_word(add, sec);

    neorv32_cpu_store_unsigned_word(add, thi);

    neorv32_cpu_store_unsigned_word(add, fou);

  // Read outputs from mult

    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);

    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE);

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE);

  // End
  neorv32_uart0_printf("\nEND-thr\n");
  #else
  int i;
  // Intro
  neorv32_uart0_printf("\n<<< MULT(P) via external memory interface (EMEM) demo program >>>\n\n");
  neorv32_uart0_printf("-------- Write data to MULT(P) --------\n");
  // Write 4 inputs to mult
    for (i=0; i<4 ; i++) {
    if(i==0){
            neorv32_cpu_store_unsigned_word(add, fir);
            neorv32_uart0_printf("\n[%i] Sending 0x%x to address 0x%x \n",i,fir,add);
           } 
    if(i==1){
            neorv32_cpu_store_unsigned_word(add, sec);
            neorv32_uart0_printf("\n[%i] Sending 0x%x to address 0x%x \n",i,sec,add);
           }   
    if(i==2){
            neorv32_cpu_store_unsigned_word(add, thi);
            neorv32_uart0_printf("\n[%i] Sending 0x%x to address 0x%x \n",i,thi,add);
           }   
    if(i==3){
            neorv32_cpu_store_unsigned_word(add, fou);
            neorv32_uart0_printf("\n[%i] Sending 0x%x to address 0x%x \n",i,fou,add);
           }   
  } 
  neorv32_uart0_printf("\n-------- Read data from MULT(P) --------\n");
  // Read outputs from mult
    for (i=0; i<4; i++) {
        neorv32_uart0_printf("\n[%i] The read data is 0x%x \n",i,neorv32_cpu_load_unsigned_word(add));
      }
  // End
  neorv32_uart0_printf("\nProgram execution completed.\n");
  #endif

  return 0;
}
\end{minted}
\caption{XBUS main.c}
\label{ap-cod:12}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{c}
#include <neorv32.h>
#include <string.h>

#define BAUD_RATE 19200

// This defines is used to bypass the intermediate print functions between cfu functions (for latency measurements)
// Comment these defines to perform a normal execution
// Uncomment lat_mult to perform latency measurements with mult_wfifos
// Uncomment lat_multpw to perform latency measurements with multp_wfifos
// Uncomment lat_multp to perform latency measurements with multp
//#define lat_mult
//#define lat_multpw
//#define lat_multp

int main() {
    
  // Capture all exceptions and give debug info via UART0
  neorv32_rte_setup();

  // Setup UART at default baud rate, no interrupts
  neorv32_uart0_setup(BAUD_RATE, 0);

  // Check if UART0 unit is implemented at all
  if (neorv32_uart0_available() == 0) {
    return -1; // abort if not implemented
  }

  // check if the CFU is implemented at all (the CFU is wrapped in the core's "Zxcfu" ISA extension)
  if (neorv32_cpu_cfu_available() == 0) {
    neorv32_uart0_printf("ERROR! CFU ('Zxcfu' ISA extensions) not implemented!\n");
    return 1;
  }

  // check if the CPU base counters are implemented
  if ((neorv32_cpu_csr_read(CSR_MXISA) & (1 << CSR_MXISA_ZICNTR)) == 0) {
    neorv32_uart0_printf("ERROR! Base counters ('Zicntr' ISA extensions) not implemented!\n");
    return -1;
  }

  // Declaration of variables 
  //0000000000000001 x 0000000000000001
  static uint32_t fir = 0x00010001;
  //0000000000000010 x 0000000000000010
  static uint32_t sec = 0x00020002;
  //0000000000000100 x 0000000000000100
  static uint32_t thi = 0x00040004;
  //0000000000001000 x 0000000000001000
  static uint32_t fou = 0x00080008;

  #ifdef lat_mult
  // Intro
  neorv32_uart0_printf("\n CFU-mw \n\n");
 // Perform 4 multiplication through custom instruction (funct3=000)
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b000, fir, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b000, sec, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b000, thi, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b000, fou, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 
  // End
  neorv32_uart0_printf("\nEND-mw\n");
  #elif defined lat_multpw
  // Intro
  neorv32_uart0_printf("\n CFU-mpw \n\n");
 // Perform 4 multiplication through custom instruction (funct3=001)
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b001, fir, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b001, sec, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b001, thi, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b001, fou, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 
  // End
  neorv32_uart0_printf("\nEND-mpw\n");
  #elif defined lat_multp
  // Intro
  neorv32_uart0_printf("\n CFU-mp \n\n");
 // Perform 4 multiplication through custom instruction (funct3=010)
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b010, fir, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b010, sec, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b010, thi, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b010, fou, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 
  // End
  neorv32_uart0_printf("\nEND-mp\n");
  #else
  int i;
  // Intro
  neorv32_uart0_printf("\n<<< MULT(P) via CFU demo program >>>\n\n");
  neorv32_uart0_printf("\n--- CFU R3-Type: Multiplier Instruction ---\n");
  neorv32_uart0_printf("\n rs1= 0xIN1-IN2, rs2= DC, rd = IN1 x IN2 \n\n");
  // Write 4 inputs to mult and read the outputs from mult one by one in mult_wfifos
    neorv32_uart0_printf("\n Mult_wfifos: \n\n");
    for (i=0; i<4 ; i++) {
    if(i==0){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b000, [rs1]=0x%x, [rs2]=0x%x ) = ", i, fir, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b000, fir, 0)); 
           } 
    if(i==1){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b000, [rs1]=0x%x, [rs2]=0x%x ) = ", i, sec, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b000, sec, 0));  
           }   
    if(i==2){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b000, [rs1]=0x%x, [rs2]=0x%x ) = ", i, thi, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b000, thi, 0));  
           }   
    if(i==3){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b000, [rs1]=0x%x, [rs2]=0x%x ) = ", i, fou, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b000, fou, 0)); 
           }   
    } 
  // Write 4 inputs to mult and read the outputs from mult one by one in multp_wfifos
    neorv32_uart0_printf("\n Multp_wfifos: \n\n");
    for (i=0; i<4 ; i++) {
    if(i==0){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b001, [rs1]=0x%x, [rs2]=0x%x ) = ", i, fir, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b001, fir, 0)); 
           } 
    if(i==1){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b001, [rs1]=0x%x, [rs2]=0x%x ) = ", i, sec, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b001, sec, 0));  
           }   
    if(i==2){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b001, [rs1]=0x%x, [rs2]=0x%x ) = ", i, thi, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b001, thi, 0));  
           }   
    if(i==3){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b001, [rs1]=0x%x, [rs2]=0x%x ) = ", i, fou, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b001, fou, 0)); 
           }   
    } 
  // Write 4 inputs to mult and read the outputs from mult one by one in multp
    neorv32_uart0_printf("\n Multp: \n\n");
    for (i=0; i<4 ; i++) {
    if(i==0){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b010, [rs1]=0x%x, [rs2]=0x%x ) = ", i, fir, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b010, fir, 0)); 
           } 
    if(i==1){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b010, [rs1]=0x%x, [rs2]=0x%x ) = ", i, sec, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b010, sec, 0));  
           }   
    if(i==2){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b010, [rs1]=0x%x, [rs2]=0x%x ) = ", i, thi, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b010, thi, 0));  
           }   
    if(i==3){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b010, [rs1]=0x%x, [rs2]=0x%x ) = ", i, fou, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b010, fou, 0)); 
           }   
    } 
  // End
  neorv32_uart0_printf("\nCFU demo program completed.\n");
  #endif

  return 0;
}
\end{minted}
\caption{CFU main.c}
\label{ap-cod:13}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{c}
#include <neorv32.h>

#define BAUD_RATE 19200

// This defines is used to bypass the intermediate print functions between cfs functions (for latency and throughput measurements)
// Comment these defines to perform a normal execution
// Uncomment latency to perform latency measurements
// Uncomment throughput to perform throughput measurements
//#define latency
//#define throughput

int main() {

  // Capture all exceptions and give debug info via UART0
  neorv32_rte_setup();

  // Setup UART at default baud rate, no interrupts
  neorv32_uart0_setup(BAUD_RATE, 0);

  // Check if UART0 unit is implemented at all
  if (neorv32_uart0_available() == 0) {
    return -1; // abort if not implemented
  }

  // check if CFS is implemented at all
  if (neorv32_cfs_available() == 0) {
    neorv32_uart0_printf("Error! No CFS synthesized!\n");
    return 1;
  }

  // check if the CPU base counters are implemented
  if ((neorv32_cpu_csr_read(CSR_MXISA) & (1 << CSR_MXISA_ZICNTR)) == 0) {
    neorv32_uart0_printf("ERROR! Base counters ('Zicntr' ISA extensions) not implemented!\n");
    return -1;
  }

  // Declaration of variables 
  //0000000000000001 x 0000000000000001
  static uint32_t fir = 0x00010001;
  //0000000000000010 x 0000000000000010
  static uint32_t sec = 0x00020002;
  //0000000000000100 x 0000000000000100
  static uint32_t thi = 0x00040004;
  //0000000000001000 x 0000000000001000
  static uint32_t fou = 0x00080008;


  #ifdef latency
  // Intro
  neorv32_uart0_printf("\n CFS-lat \n\n");
  // Write 4 inputs to mult and read the outputs from mult one by one
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = fir; // Write fir to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write fir to mult
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read fir from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = sec; // Write sec to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write sec to mult
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read sec from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = thi; // Write thi to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write thi to mult
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read thi from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = fou; // Write fou to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write fou to mult
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read fou from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

  // End
  neorv32_uart0_printf("\nEND-lat\n");
  #elif defined throughput
  // Intro
  neorv32_uart0_printf("\n CFS-thr \n\n");
  // Write 4 inputs to mult
    NEORV32_CFS->REG[0] = fir; // Write fir to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write fir to mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals

    NEORV32_CFS->REG[0] = sec; // Write sec to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write sec to mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals

    NEORV32_CFS->REG[0] = thi; // Write thi to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write thi to mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals

    NEORV32_CFS->REG[0] = fou; // Write fou to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write fou to mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals

  // Read outputs from mult
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read data from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);

    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read data from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read data from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read data from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

  // End
  neorv32_uart0_printf("\nEND-thr\n");
  #else
  // Intro
  int i;
  neorv32_uart0_printf("\n<<< MULT(P) via CFS demo program >>>\n\n");
  neorv32_uart0_printf("CFS memory-mapped registers:\n"
                       " * NEORV32_CFS->REG[0] (r/w): input/output data register.\n"
                       " * NEORV32_CFS->REG[1] (w): control signals register. 01 Write to MULT(P) - 10 Read from MULT(P) - 00 Clean control signals\n\n");
  neorv32_uart0_printf("-------- Write data to MULT(P) --------\n");
  // Write 4 inputs to mult and read the outputs from mult one by one
    for (i=0; i<4 ; i++) {
    if(i==0){
            NEORV32_CFS->REG[0] = fir; // Write fir to CFS memory-mapped register 0
            NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write fir to mult
            NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read fir from mult
            NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, fir, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           } 
    if(i==1){
            NEORV32_CFS->REG[0] = sec; // Write sec to CFS memory-mapped register 0
            NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write sec to mult
            NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read sec from mult
            NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, sec, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           }   
    if(i==2){
            NEORV32_CFS->REG[0] = thi; // Write thi to CFS memory-mapped register 0
            NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write thi to mult
            NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read thi from mult
            NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, thi, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           }   
    if(i==3){
            NEORV32_CFS->REG[0] = fou; // Write fou to CFS memory-mapped register 0
            NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write fou to mult
            NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read fou from mult
            NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, fou, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           }   
    } 
  // End
  neorv32_uart0_printf("\nCFS demo program completed.\n");
  #endif

  return 0;
}
\end{minted}
\caption{CFS \textit{buffered} main.c}
\label{ap-cod:14}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{c}
#include <neorv32.h>

#define BAUD_RATE 19200

// This defines is used to bypass the intermediate print functions between CFS functions (for latency measurements)
// Comment these defines to perform a normal execution
// Uncomment latency to perform latency measurements
//#define latency

int main() {

  // Capture all exceptions and give debug info via UART0
  neorv32_rte_setup();

  // Setup UART at default baud rate, no interrupts
  neorv32_uart0_setup(BAUD_RATE, 0);

  // Check if UART0 unit is implemented at all
  if (neorv32_uart0_available() == 0) {
    return -1; // abort if not implemented
  }

  // check if CFS is implemented at all
  if (neorv32_cfs_available() == 0) {
    neorv32_uart0_printf("Error! No CFS synthesized!\n");
    return 1;
  }

  // check if the CPU base counters are implemented
  if ((neorv32_cpu_csr_read(CSR_MXISA) & (1 << CSR_MXISA_ZICNTR)) == 0) {
    neorv32_uart0_printf("ERROR! Base counters ('Zicntr' ISA extensions) not implemented!\n");
    return -1;
  }

  // Declaration of variables 
  //0000000000000001 x 0000000000000001
  static uint32_t fir = 0x00010001;
  //0000000000000010 x 0000000000000010
  static uint32_t sec = 0x00020002;
  //0000000000000100 x 0000000000000100
  static uint32_t thi = 0x00040004;
  //0000000000001000 x 0000000000001000
  static uint32_t fou = 0x00080008;


  #ifdef latency
  // Intro
  neorv32_uart0_printf("\n CFS-lat \n\n");
  // Write 4 inputs to mult and read the outputs from mult one by one
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = fir; // Write fir to CFS memory-mapped register 0
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = sec; // Write sec to CFS memory-mapped register 0
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = thi; // Write thi to CFS memory-mapped register 0
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = fou; // Write fou to CFS memory-mapped register 0
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

  // End
  neorv32_uart0_printf("\nEND-lat\n");
  #else
  // Intro
  int i;
  neorv32_uart0_printf("\n<<< MULT(P) via CFS demo program >>>\n\n");
  neorv32_uart0_printf("CFS memory-mapped registers:\n"
                       " * NEORV32_CFS->REG[0] (r/w): input/output data register.\n\n");
  neorv32_uart0_printf("-------- Write data to MULT(P) --------\n");
  // Write 4 inputs to mult and read the outputs from mult one by one
    for (i=0; i<4 ; i++) {
    if(i==0){
            NEORV32_CFS->REG[0] = fir; // Write fir to CFS memory-mapped register 0
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, fir, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           } 
    if(i==1){
            NEORV32_CFS->REG[0] = sec; // Write sec to CFS memory-mapped register 0
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, sec, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           }   
    if(i==2){
            NEORV32_CFS->REG[0] = thi; // Write thi to CFS memory-mapped register 0
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, thi, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           }   
    if(i==3){
            NEORV32_CFS->REG[0] = fou; // Write fou to CFS memory-mapped register 0
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, fou, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           }   
    } 
  // End
  neorv32_uart0_printf("\nCFS demo program completed.\n");
  #endif

  return 0;
}
\end{minted}
\caption{CFS \textit{unbuffered} main.c}
\label{ap-cod:15}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- ================================================================================ --
-- NEORV32 CPU - Co-Processor: Custom (RISC-V Instructions) Functions Unit (CFU)    --
-- -------------------------------------------------------------------------------- --
-- For custom/user-defined RISC-V instructions (R3-type, R4-type and R5-type        --
-- formats). See the  CPU's documentation for more information. Also take a look at --
-- the "software-counterpart" this default CFU hardware in 'sw/example/demo_cfu'.   --
-- -------------------------------------------------------------------------------- --
-- The NEORV32 RISC-V Processor - https://github.com/stnolting/neorv32              --
-- Copyright (c) NEORV32 contributors.                                              --
-- Copyright (c) 2020 - 2024 Stephan Nolting. All rights reserved.                  --
-- Licensed under the BSD-3-Clause license, see LICENSE for details.                --
-- SPDX-License-Identifier: BSD-3-Clause                                            --
-- ================================================================================ --

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library neorv32;
use neorv32.neorv32_package.all;

entity neorv32_cpu_cp_cfu is
  port (
    -- global control --
    clk_i       : in  std_ulogic; -- global clock, rising edge
    rstn_i      : in  std_ulogic; -- global reset, low-active, async
    ctrl_i      : in  ctrl_bus_t; -- main control bus
    start_i     : in  std_ulogic; -- trigger operation
    -- CSR interface --
    csr_we_i    : in  std_ulogic; -- write enable
    csr_addr_i  : in  std_ulogic_vector(1 downto 0); -- address
    csr_wdata_i : in  std_ulogic_vector(XLEN-1 downto 0); -- write data
    csr_rdata_o : out std_ulogic_vector(XLEN-1 downto 0) := (others => '0'); -- read data
    -- data input --
    rs1_i       : in  std_ulogic_vector(XLEN-1 downto 0); -- rf source 1
    rs2_i       : in  std_ulogic_vector(XLEN-1 downto 0); -- rf source 2
    rs3_i       : in  std_ulogic_vector(XLEN-1 downto 0); -- rf source 3
    rs4_i       : in  std_ulogic_vector(XLEN-1 downto 0); -- rf source 4
    -- result and status --
    res_o       : out std_ulogic_vector(XLEN-1 downto 0) := (others => '0'); -- operation result
    valid_o     : out std_ulogic := '0' -- data output valid
  );
end neorv32_cpu_cp_cfu;

architecture neorv32_cpu_cp_cfu_rtl of neorv32_cpu_cp_cfu is

  -- CFU Control ---------------------------------------------
  -- ------------------------------------------------------------
  type control_t is record
    busy   : std_ulogic; -- CFU is busy
    done   : std_ulogic; -- set to '1' when processing is done
    result : std_ulogic_vector(XLEN-1 downto 0); -- CFU processing result (for write-back to register file)
    rtype  : std_ulogic_vector(1 downto 0); -- instruction type, see constants below
    funct3 : std_ulogic_vector(2 downto 0); -- "funct3" bit-field from custom instruction word
    funct7 : std_ulogic_vector(6 downto 0); -- "funct7" bit-field from custom instruction word
  end record;
  signal control : control_t;

  -- instruction format types --
  constant r3type_c  : std_ulogic_vector(1 downto 0) := "00"; -- R3-type instructions (custom-0 opcode)
  constant r4type_c  : std_ulogic_vector(1 downto 0) := "01"; -- R4-type instructions (custom-1 opcode)
  constant r5typeA_c : std_ulogic_vector(1 downto 0) := "10"; -- R5-type instruction A (custom-2 opcode)
  constant r5typeB_c : std_ulogic_vector(1 downto 0) := "11"; -- R5-type instruction B (custom-3 opcode)

  -- User-Defined Logic --------------------------------------
  -- ------------------------------------------------------------

  constant N_bits : natural := 32; -- 32 bits (16 bits plus 16 bits)
  constant Log2_elements : natural := 2; -- Log2 is 2 ergo FIFO has 4 elements

  signal reset : std_logic;

  type mult_wfifos_t is record
    sreg : std_ulogic_vector(5 downto 0); -- 6 cycles latency = 6 bits in arbitration shift register + 1 cycle for output = 7 cycles in total
    done : std_logic;
    --
    input : std_logic_vector(31 downto 0);
    output : std_logic_vector(31 downto 0);
    output_u  : std_ulogic_vector(31 downto 0);
    wr : std_logic;
    rd : std_logic;
  end record;
  signal mw : mult_wfifos_t;

  type multp_wfifos_t is record
    sreg : std_ulogic_vector(3 downto 0); -- 4 cycles latency = 4 bits in arbitration shift register + 1 cycle for output = 5 cycles in total
    done : std_logic;
    --
    input : std_logic_vector(31 downto 0);
    output : std_logic_vector(31 downto 0);
    output_u  : std_ulogic_vector(31 downto 0);
    wr : std_logic;
    rd : std_logic;
  end record;
  signal mpw : multp_wfifos_t;

  type multp_t is record
    sreg : std_logic; -- 1 cycle latency = 1 bit in arbitration shift register + 1 cycle for output = 2 cycles in total
    done : std_logic;
    --
    input : std_logic_vector(31 downto 0);
    output : std_logic_vector(31 downto 0);
    output_u  : std_ulogic_vector(31 downto 0);
  end record;
  signal mp : multp_t;

begin

  -- **************************************************************************************************************************
  -- This controller is required to handle the CFU-CPU interface.
  -- **************************************************************************************************************************

  -- CFU Controller -------------------------------------------------------------------------
  -- -------------------------------------------------------------------------------------------
  -- The <control> record acts as proxy logic that ensures correct communication with the
  -- CPU pipeline. However, this control instance adds one additional cycle of latency.
  -- Advanced users can remove this default control instance to obtain maximum throughput.
  cfu_control: process(rstn_i, clk_i)
  begin
    if (rstn_i = '0') then
      res_o        <= (others => '0');
      control.busy <= '0';
    elsif rising_edge(clk_i) then
      res_o <= (others => '0'); -- default; all CPU co-processor outputs are logically OR-ed
      if (control.busy = '0') then -- CFU is idle
        control.busy <= start_i; -- trigger new CFU operation
      else -- CFU operation in progress
        res_o <= control.result; -- output result only if CFU is processing; has to be all-zero otherwise
        if (control.done = '1') or (ctrl_i.cpu_trap = '1') then -- operation done or abort if trap (exception)
          control.busy <= '0';
        end if;
      end if;
    end if;
  end process cfu_control;

  -- CPU feedback --
  valid_o <= control.busy and control.done; -- set one cycle before result data

  -- pack user-defined instruction type/function bits --
  control.rtype  <= ctrl_i.ir_opcode(6 downto 5);
  control.funct3 <= ctrl_i.ir_funct3;
  control.funct7 <= ctrl_i.ir_funct12(11 downto 5);


  -- **************************************************************************************************************************
  -- CFU Hardware Documentation
  -- **************************************************************************************************************************

  -- ----------------------------------------------------------------------------------------
  -- CFU Instruction Formats
  -- ----------------------------------------------------------------------------------------
  -- The CFU supports three instruction types:
  --
  -- Up to 1024 RISC-V R3-Type Instructions (RISC-V standard):
  -- This format consists of two source registers ('rs1', 'rs2'), a destination register ('rd') and two "immediate" bit-fields
  -- ('funct7' and 'funct3').
  --
  -- Up to 8 RISC-V R4-Type Instructions (RISC-V standard):
  -- This format consists of three source registers ('rs1', 'rs2', 'rs3'), a destination register ('rd') and one "immediate"
  -- bit-field ('funct3').
  --
  -- Two individual RISC-V R5-Type Instructions (NEORV32-specific):
  -- This format consists of four source registers ('rs1', 'rs2', 'rs3', 'rs4') and a destination register ('rd'). There are
  -- no immediate fields.

  -- ----------------------------------------------------------------------------------------
  -- Input Operands
  -- ----------------------------------------------------------------------------------------
  -- > rs1_i          (input, 32-bit): source register 1; selected by 'rs1' bit-field
  -- > rs2_i          (input, 32-bit): source register 2; selected by 'rs2' bit-field
  -- > rs3_i          (input, 32-bit): source register 3; selected by 'rs3' bit-field
  -- > rs4_i          (input, 32-bit): source register 4; selected by 'rs4' bit-field
  -- > control.rtype  (input,  2-bit): defining the R-type; driven by OPCODE
  -- > control.funct3 (input,  3-bit): 3-bit function select / immediate value; driven by instruction word's 'funct3' bit-field
  -- > control.funct7 (input,  7-bit): 7-bit function select / immediate value; driven by instruction word's 'funct7' bit-field
  --
  -- [NOTE] The set of usable signals depends on the actual R-type of the instruction.
  --
  -- The general instruction type is identified by the <control.rtype>.
  -- > r3type_c  - R3-type instructions (custom-0 opcode)
  -- > r4type_c  - R4-type instructions (custom-1 opcode)
  -- > r5typeA_c - R5-type instruction A (custom-2 opcode)
  -- > r5typeB_c - R5-type instruction B (custom-3 opcode)
  --
  -- The four signals <rs1_i>, <rs2_i>, <rs3_i> and <rs4_i> provide the source operand data read from the CPU's register file.
  -- The source registers are adressed by the custom instruction word's 'rs1', 'rs2', 'rs3' and 'rs4' bit-fields.
  --
  -- The actual CFU operation can be defined by using the <control.funct3> and/or <control.funct7> signals (if available for a
  -- certain R-type instruction). Both signals are directly driven by the according bit-fields of the custom instruction word.
  -- These immediates can be used to select the actual function or to provide small literals for certain operations (like shift
  -- amounts, offsets, multiplication factors, ...).
  --
  -- [NOTE] <rs1_i>, <rs2_i>, <rs3_i> and <rs4_i> are directly driven by the register file (e.g. block RAM). For complex CFU
  --        designs it is recommended to buffer these signals using CFU-internal registers before actually using them.
  --
  -- [NOTE] The R4-type instructions and R5-type instruction provide additional source register. When used, this will increase
  --        the hardware requirements of the register file.

  -- ----------------------------------------------------------------------------------------
  -- Result Output
  -- ----------------------------------------------------------------------------------------
  -- > control.result (output, 32-bit): processing result
  --
  -- When the CFU has completed computations, the data send via the <control.result> signal will be written to the CPU's register
  -- file. The destination register is addressed by the <rd> bit-field in the instruction word. The CFU result output is registered
  -- in the CFU controller (see above) - so do not worry too much about increasing the CPU's critical path with your custom
  -- logic.

  -- ----------------------------------------------------------------------------------------
  -- Processing Control
  -- ----------------------------------------------------------------------------------------
  -- > rstn_i       (input,  1-bit): asynchronous reset, low-active
  -- > clk_i        (input,  1-bit): main clock, triggering on rising edge
  -- > start_i      (input,  1-bit): operation trigger (start processing, high for one cycle)
  -- > control.done (output, 1-bit): set high when processing is done
  --
  -- For pure-combinatorial instructions (completing within 1 clock cycle) <control.done> can be tied to 1. If the CFU requires
  -- several clock cycles for internal processing, the <start_i> signal can be used to *start* a new iterative operation. As soon
  -- as all internal computations have completed, the <control.done> signal has to be set to indicate completion. This will
  -- complete CFU instruction operation and will also write the processing result <control.result> back to the CPU register file.

  -- ----------------------------------------------------------------------------------------
  -- CFU Exception
  -- ----------------------------------------------------------------------------------------
  -- The CFU does not provide a dedicated exception mechanism. However, if the <control.done> signal is not set within a bound
  -- time window (default = 512 cycles; see "monitor_mc_tmo_c" constant in the main NEORV32 package file) the CFU operation is
  -- automatically terminated by the hardware and an **illegal instruction exception** is raised. This default mechanism combined
  -- with according software handling can be used to "emulate" dedicated CFU exceptions.

  -- ----------------------------------------------------------------------------------------
  -- CFU-Internal Control and Status Registers (CFU-CSRs)
  -- ----------------------------------------------------------------------------------------
  -- > csr_we_i    (input,   1-bit): set to indicate a valid CFU CSR write access
  -- > csr_addr_i  (input,   2-bit): CSR address
  -- > csr_wdata_i (input,  32-bit): CSR write data
  -- > csr_rdata_i (output, 32-bit): CSR read data
  --
  -- The NEORV32 provides four directly accessible CSRs for custom use inside the CFU. These registers can be used to pass
  -- further operands, to check the unit's status or to configure operation modes. For instance, a 128-bit wide key could be
  -- passed to an encryption system.
  --
  -- If more than four CFU-internal CSRs are required the designer can implement an "indirect access mechanism" based on just
  -- two of the default CSRs: one CSR is used to configure the index while the other is used as an alias to exchange data with
  -- the indexed CFU-internal CSR - this concept is similar to the RISC-V Indirect CSR Access Extension Specification (Smcsrind).


  -- **************************************************************************************************************************
  -- Actual CFU User Logic Example: XTEA - Extended Tiny Encryption Algorithm (replace this with your custom logic)
  -- **************************************************************************************************************************

  reset <= not(rstn_i);

  -- Mult_wfifos instantation

  mult_wfifos_0 : entity work.mult_wfifos
                generic map (N_bits => N_bits,
                             Log2_elements => Log2_elements)
                port map (clk_wr => clk_i,
                          clk_mult => clk_i,
                          clk_rd => clk_i,
                          rst => reset,
                          din => mw.input,
                          dout => mw.output,
                          wr => mw.wr,
                          rd => mw.rd,
                          full => open,
                          empty => open);

  -- Multp_wfifos instantation

  multp_wfifos_0 : entity work.multp_wfifos
                 generic map (g_data_width => N_bits,
                              g_fifo_depth => Log2_elements)
                 port map (clk_in => clk_i,
                           clk_mult => clk_i,
                           clk_out => clk_i,
                           rst => reset,
                           din => mpw.input,
                           dout => mpw.output,
                           write => mpw.wr,
                           read => mpw.rd,
                           full => open,
                           empty => open);

  -- Multp instantation

  multp_0 : entity work.multp_op
                 generic map (g_data_width => N_bits)
                 port map (din => mp.input,
                           dout => mp.output);

  -- Inputs
  mw.input <= To_StdLogicVector(rs1_i)  when control.funct3 = "000" and start_i = '1' else
              (others => '0');
  mpw.input <= To_StdLogicVector(rs1_i) when control.funct3 = "001" and start_i = '1' else
              (others => '0');
  mp.input <= To_StdLogicVector(rs1_i)  when mp.done = '1' else
              (others => '0');

  -- Outputs
  mw.output_u <= To_StdULogicVector(mw.output);
  mpw.output_u <= To_StdULogicVector(mpw.output);
  mp.output_u <= To_StdULogicVector(mp.output);

    -- Iteration control
    iteration_control: process(rstn_i, clk_i)
    begin
      if (rstn_i = '0') then
        mw.sreg <= (others => '0');
        mpw.sreg <= (others => '0');
        mp.sreg <= '0';
      elsif rising_edge(clk_i) then
        -- operation trigger --
        if (control.busy = '0') and -- CFU is idle (ready for next operation)
           (start_i = '1') and -- CFU is actually triggered by a custom instruction word
           (control.rtype = r3type_c) and -- this is a R3-type instruction
           (control.funct3 = "000") then -- trigger only for 000 funct3 value
             mw.sreg(0) <= '1';
        elsif (control.busy = '0') and -- CFU is idle (ready for next operation)
              (start_i = '1') and -- CFU is actually triggered by a custom instruction word
              (control.rtype = r3type_c) and -- this is a R3-type instruction
              (control.funct3 = "001") then -- trigger only for 001 funct3 value
             mpw.sreg(0) <= '1';
        elsif (control.busy = '0') and -- CFU is idle (ready for next operation)
              (start_i = '1') and -- CFU is actually triggered by a custom instruction word
              (control.rtype = r3type_c) and -- this is a R3-type instruction
              (control.funct3 = "010") then -- trigger only for 010 funct3 value
             mp.sreg <= '1';
        else
             mw.sreg(0) <= '0';
             mpw.sreg(0) <= '0';
             mp.sreg <= '0';
        end if;
        -- simple shift register for tracking operation --
          mw.sreg(mw.sreg'left downto 1) <= mw.sreg(mw.sreg'left-1 downto 0); -- shift left
          mpw.sreg(mpw.sreg'left downto 1) <= mpw.sreg(mpw.sreg'left-1 downto 0); -- shift left
        end if;
      end process iteration_control;

      -- Processing has reached last stage (= done) when mult_wfifos sreg's MSB is set --
      mw.done <= mw.sreg(mw.sreg'left);

      -- Processing has reached last stage (= done) when multp_wfifos sreg's MSB is set --
      mpw.done <= mpw.sreg(mpw.sreg'left);

      -- Processing has reached last stage (= done) when multp sreg is equal to 1 --
      mp.done <= mp.sreg;

      -- Write signal for mult_wfifos when the operation starts
      mw.wr <= start_i when control.funct3 = "000" else
               '0';
      -- Write signal for multp_wfifos when the operation starts
      mpw.wr <= start_i when control.funct3 = "001" else
               '0';
      -- Read signal for mult_wfifos in the fifth iteration
      mw.rd <= mw.sreg(4);
      -- Read signal for multp_wfifos in the third iteration
      mpw.rd <= mpw.sreg(2);

-- Output select --------------------------------------------------------------------------
  -- -------------------------------------------------------------------------------------------
    out_select: process(control, rs1_i, rs2_i, mw, mpw, mp)
    begin
      case control.rtype is
        when r3type_c => -- R3-type instructions
          case control.funct3 is
            when "000" => -- funct3 = "000": mult_wfifos
              control.result <= mw.output_u;
              control.done   <= mw.done; -- 6 cycles to perform multiplication
            when "001" => -- funct3 = "001": multp_wfifos
              control.result <= mpw.output_u;
              control.done   <= mpw.done; -- 4 cycles to perform multiplication
            when "010" => -- funct3 = "010": multp
              control.result <= mp.output_u;
              control.done   <= mp.done; -- 1 cycle to perform multiplication
            when others => -- not implemented
              control.result <= (others => '0');
              control.done   <= '0'; -- this will cause an illegal instruction exception after timeout
          end case;
        when others => -- undefined
        -- ----------------------------------------------------------------------
          control.result <= (others => '0');
          control.done   <= '0';
      end case;
    end process out_select;

end neorv32_cpu_cp_cfu_rtl;
\end{minted}
\caption{Archivo neorv32\_cpu\_cp\_cfu.vhd modificado para integrar los multiplicadores.}
\label{ap-cod:16}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- ================================================================================ --
-- NEORV32 SoC - Custom Functions Subsystem (CFS)                                   --
-- -------------------------------------------------------------------------------- --
-- Intended for tightly-coupled, application-specific custom co-processors. This    --
-- module provides up to 64x 32-bit memory-mapped interface registers, one CPU      --
-- interrupt request signal and custom IO conduits for processor-external or chip-  --
-- external interface.                                                              --
-- -------------------------------------------------------------------------------- --
-- The NEORV32 RISC-V Processor - https://github.com/stnolting/neorv32              --
-- Copyright (c) NEORV32 contributors.                                              --
-- Copyright (c) 2020 - 2024 Stephan Nolting. All rights reserved.                  --
-- Licensed under the BSD-3-Clause license, see LICENSE for details.                --
-- SPDX-License-Identifier: BSD-3-Clause                                            --
-- ================================================================================ --

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library neorv32;
use neorv32.neorv32_package.all;

entity neorv32_cfs is
  generic (
    CFS_CONFIG   : std_ulogic_vector(31 downto 0); -- custom CFS configuration generic
    CFS_IN_SIZE  : natural; -- size of CFS input conduit in bits
    CFS_OUT_SIZE : natural  -- size of CFS output conduit in bits
  );
  port (
    clk_i       : in  std_ulogic; -- global clock line
    rstn_i      : in  std_ulogic; -- global reset line, low-active, use as async
    bus_req_i   : in  bus_req_t; -- bus request
    bus_rsp_o   : out bus_rsp_t := rsp_terminate_c; -- bus response
    clkgen_en_o : out std_ulogic := '0'; -- enable clock generator
    clkgen_i    : in  std_ulogic_vector(7 downto 0); -- "clock" inputs
    irq_o       : out std_ulogic := '0'; -- interrupt request
    cfs_in_i    : in  std_ulogic_vector(CFS_IN_SIZE-1 downto 0); -- custom inputs
    cfs_out_o   : out std_ulogic_vector(CFS_OUT_SIZE-1 downto 0) := (others => '0') -- custom outputs
  );
end neorv32_cfs;

architecture neorv32_cfs_rtl of neorv32_cfs is

  -- MULT(P) interface registers --
  signal cfs_mult_data : std_ulogic_vector(31 downto 0);
  signal cfs_mult_control : std_ulogic_vector(31 downto 0);
  signal cfs_mult_res : std_ulogic_vector(31 downto 0);

begin

  -- CFS Generics ---------------------------------------------------------------------------
  -- -------------------------------------------------------------------------------------------
  -- In it's default version the CFS provides three configuration generics:
  -- > CFS_IN_SIZE  - configures the size (in bits) of the CFS input conduit cfs_in_i
  -- > CFS_OUT_SIZE - configures the size (in bits) of the CFS output conduit cfs_out_o
  -- > CFS_CONFIG   - is a blank 32-bit generic. It is intended as a "generic conduit" to propagate
  --                  custom configuration flags from the top entity down to this module.

  -- CFS IOs --------------------------------------------------------------------------------
  -- -------------------------------------------------------------------------------------------
  -- By default, the CFS provides two IO signals (cfs_in_i and cfs_out_o) that are available at the processor's top entity.
  -- These are intended as "conduits" to propagate custom signals from this module and the processor top entity.

  -- Reset System ---------------------------------------------------------------------------
  -- -------------------------------------------------------------------------------------------
  -- The CFS can be reset using the global rstn_i signal. This signal should be used as asynchronous reset and is active-low.
  -- Note that rstn_i can be asserted by a processor-external reset, the on-chip debugger and also by the watchdog.
  --
  -- Most default peripheral devices of the NEORV32 do NOT use a dedicated hardware reset at all. Instead, these units are
  -- reset by writing ZERO to a specific "control register" located right at the beginning of the device's address space
  -- (so this register is cleared at first). The crt0 start-up code writes ZERO to every single address in the processor's
  -- IO space - including the CFS. Make sure that this initial clearing does not cause any unintended CFS actions.


  -- Clock System ---------------------------------------------------------------------------
  -- -------------------------------------------------------------------------------------------
  -- The processor top unit implements a clock generator providing 8 "derived clocks".
  -- Actually, these signals should not be used as direct clock signals, but as *clock enable* signals.
  -- clkgen_i is always synchronous to the main system clock (clk_i).
  --
  -- The following clock dividers are available:
  -- > clkgen_i(clk_div2_c)    -> MAIN_CLK/2
  -- > clkgen_i(clk_div4_c)    -> MAIN_CLK/4
  -- > clkgen_i(clk_div8_c)    -> MAIN_CLK/8
  -- > clkgen_i(clk_div64_c)   -> MAIN_CLK/64
  -- > clkgen_i(clk_div128_c)  -> MAIN_CLK/128
  -- > clkgen_i(clk_div1024_c) -> MAIN_CLK/1024
  -- > clkgen_i(clk_div2048_c) -> MAIN_CLK/2048
  -- > clkgen_i(clk_div4096_c) -> MAIN_CLK/4096
  --
  -- For instance, if you want to drive a clock process at MAIN_CLK/8 clock speed you can use the following construct:
  --
  --   if (rstn_i = '0') then -- async and low-active reset (if required at all)
  --   ...
  --   elsif rising_edge(clk_i) then -- always use the main clock for all clock processes
  --     if (clkgen_i(clk_div8_c) = '1') then -- the div8 "clock" is actually a clock enable
  --       ...
  --     end if;
  --   end if;
  --
  -- The clkgen_i input clocks are available when at least one IO/peripheral device (for example UART0) requires the clocks
  -- generated by the clock generator. The CFS can enable the clock generator by itself by setting the clkgen_en_o signal high.
  -- The CFS cannot ensure to deactivate the clock generator by setting the clkgen_en_o signal low as other peripherals might
  -- still keep the generator activated. Make sure to deactivate the CFS's clkgen_en_o if no clocks are required in here to
  -- reduce dynamic power consumption.

  clkgen_en_o <= '0'; -- not used for this minimal example


  -- Interrupt ------------------------------------------------------------------------------
  -- -------------------------------------------------------------------------------------------
  -- The CFS features a single interrupt signal, which is connected to the CPU's "fast interrupt" channel 1 (FIRQ1).
  -- The according CPU interrupt becomes pending as long as <irq_o> is high.

  irq_o <= '0'; -- not used for this minimal example


  -- Read/Write Access ----------------------------------------------------------------------
  -- -------------------------------------------------------------------------------------------
  -- Here we are reading/writing from/to the interface registers of the module and generate the CPU access handshake (bus response).
  --
  -- The CFS provides up to 64 memory-mapped 32-bit interface registers. For instance, these could be used to provide a
  -- <control register> for global control of the unit, a <data register> for reading/writing from/to a data FIFO, a
  -- <command register> for issuing commands and a <status register> for status information.
  --
  -- Following the interface protocol, each read or write access has to be acknowledged in the following cycle using the ack_o
  -- signal (or even later if the module needs additional time). If no ACK is generated at all, the bus access will time out
  -- and cause a bus access fault exception. The current CPU privilege level is available via the 'priv_i' signal (0 = user mode,
  -- 1 = machine mode), which can be used to constrain access to certain registers or features to privileged software only.
  --
  -- This module also provides an optional ERROR signal to indicate a faulty access operation (for example when accessing an
  -- unused, read-only or "locked" CFS register address). This signal may only be set when the module is actually accessed
  -- and is set INSTEAD of the ACK signal. Setting the ERR signal will raise a bus access exception with a "Device Error" qualifier
  -- that can be handled by the application software. Note that the current privilege level should not be exposed to software to
  -- maintain full virtualization. Hence, CFS-based "privilege escalation" should trigger a bus access exception (e.g. by setting 'err_o').
  --
  -- Host access example: Read and write access to the interface registers + bus transfer acknowledge. This example only
  -- implements four physical r/w register (the four lowest CFS registers). The remaining addresses of the CFS are not associated
  -- with any physical registers - any access to those is simply ignored but still acknowledged. Only full-word write accesses are
  -- supported (and acknowledged) by this example. Sub-word write access will not alter any CFS register state and will cause
  -- a "bus store access" exception (with a "Device Timeout" qualifier as not ACK is generated in that case).

  bus_access: process(rstn_i, clk_i)
  begin
    if (rstn_i = '0') then
      cfs_mult_data <= (others => '0');
      cfs_mult_control <= (others => '0');
      --
      bus_rsp_o.ack  <= '0';
      bus_rsp_o.err  <= '0';
      bus_rsp_o.data <= (others => '0');
    elsif rising_edge(clk_i) then -- synchronous interface for read and write accesses
      -- transfer/access acknowledge --
      bus_rsp_o.ack <= bus_req_i.stb;

      -- tie to zero if not explicitly used --
      bus_rsp_o.err <= '0';

      -- defaults --
      bus_rsp_o.data <= (others => '0'); -- the output HAS TO BE ZERO if there is no actual (read) access

      -- bus access --
      if (bus_req_i.stb = '1') then -- valid access cycle, STB is high for one cycle

        -- write access --
        if (bus_req_i.rw = '1') then
          if (bus_req_i.addr(7 downto 2) = "000000") then -- address size is fixed!
            cfs_mult_data <= bus_req_i.data; -- write to CFS memory-mapped register 0; MULT(P) inputs
          end if;
          if (bus_req_i.addr(7 downto 2) = "000001") then
            cfs_mult_control <= bus_req_i.data; -- write to CFS memory-mapped register 1; MULT(P) control
          end if;

        -- read access --
        else
          case bus_req_i.addr(7 downto 2) is -- address size is fixed!
            when "000000" => bus_rsp_o.data <= cfs_mult_res; -- read from CFS memory-mapped register 0; MULT(P) outputs
            when others   => bus_rsp_o.data <= (others => '0');
          end case;
        end if;

      end if;
    end if;
  end process bus_access;

-- cfs_mult_control(1) => Read from MULT(P)
-- cfs_mult_control(0) => Write to MULT(P)

-- Concatenate/make output; cfs_out_o => 34 bits (2 bit for control MSB + 32 bit for data)
 cfs_out_o <= cfs_mult_control(1) & cfs_mult_control(0) & cfs_mult_data; 

-- cfs_in_i => 32 bits; MULT(P) output (16 bits x 16 bits)

 cfs_mult_res <= cfs_in_i;

end neorv32_cfs_rtl;
\end{minted}
\caption{Archivo neorv32\_cfs.vhd modificado para gestionar los multiplicadores \textit{buffered}.}
\label{ap-cod:17}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
library ieee;
context ieee.ieee_std_context;

library neorv32;
use neorv32.neorv32_package.all;

library vunit_lib;
context vunit_lib.vunit_context;

entity tb_complex_mults_cfu is
  generic (
    runner_cfg : string
  );
end entity;

architecture tb of tb_complex_mults_cfu is

signal clk : std_logic := '0';
signal rst : std_logic := '0';
signal rstn : std_logic := '0';
signal gpio_a : std_ulogic_vector(7 downto 0);
signal uart0_txd : std_logic;

constant baud0_rate_c            : natural := 19200;
constant CLOCK_FREQUENCY         : natural := 100000000;

constant uart0_baud_val_c : real := real(CLOCK_FREQUENCY) / real(baud0_rate_c);

constant clk_period : time := 10 ns;

signal ctrl_bus : ctrl_bus_t;

signal funct3 : std_ulogic_vector(2 downto 0);
signal rs1 : std_ulogic_vector(31 downto 0);
signal res_CFU : std_ulogic_vector(31 downto 0);
signal start_CFU : std_logic;

signal csr_we : std_logic;
signal csr_valid : std_logic;
signal csr_addr : std_ulogic_vector(11 downto 0);
signal csr_wdata : std_ulogic_vector(31 downto 0);
signal csr_rdata_o : std_ulogic_vector(31 downto 0);


-- Logging

constant logger : logger_t := get_logger("tb_complex_mults_cfu");
constant file_handler : log_handler_t := new_log_handler(
  output_path(runner_cfg) & "log.csv",
  format => csv,
  use_color => false
);

-- Test items (make sure that they are equal to the items defined in the software)

constant test_items : natural := 4;
type test_t is array (0 to test_items-1, 0 to 2) of integer;
constant test_data : test_t := (
  (1, 1, 1),
  (2, 2, 4),
  (4, 4, 16),
  (8, 8, 64)
);

signal start, done: boolean := false;

begin

neorv32_mults_cfu_0 : entity work.neorv32_mults_cfu
                                                generic map(
                                                            CLOCK_FREQUENCY => CLOCK_FREQUENCY,
                                                            MEM_INT_IMEM_SIZE => 16384,
                                                            MEM_INT_DMEM_SIZE => 8192
                                                           )
                                                port map (
                                                            clk_i => clk,
                                                            rstn_i => rstn,
                                                            gpio_o => gpio_a,
                                                            uart0_txd_o => uart0_txd,
                                                            uart0_rxd_i => uart0_txd
                                                          );
  -- UART Simulation Receiver ---------------------------------------------------------------
  -- -------------------------------------------------------------------------------------------
  uart0_checker: entity work.uart_rx_simple
  generic map (
    name => "uart0",
    uart_baud_val_c => uart0_baud_val_c
  )
  port map (
    clk => clk,
    uart_txd => uart0_txd
  );

  clk <= not clk after clk_period/2;
  rstn <= not rst;

  -- Capture control bus through external names

  ctrl_bus <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst.neorv32_cpu_alu_inst.neorv32_cpu_cp_cfu_inst_true.neorv32_cpu_cp_cfu_inst.ctrl_i : ctrl_bus_t >>;

  -- To display in vcd file 
  funct3 <= ctrl_bus.ir_funct3;

  rs1 <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst.neorv32_cpu_alu_inst.neorv32_cpu_cp_cfu_inst_true.neorv32_cpu_cp_cfu_inst.rs1_i : std_ulogic_vector(31 downto 0) >>;
  res_CFU <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst.neorv32_cpu_alu_inst.neorv32_cpu_cp_cfu_inst_true.neorv32_cpu_cp_cfu_inst.res_o : std_ulogic_vector(31 downto 0) >>;
  start_CFU <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst.neorv32_cpu_alu_inst.neorv32_cpu_cp_cfu_inst_true.neorv32_cpu_cp_cfu_inst.start_i : std_logic >>;

  -- Capture CSR signals through external names
  csr_we <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst.neorv32_cpu_control_inst.xcsr_we_o : std_logic >>;
  csr_addr <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst.neorv32_cpu_control_inst.xcsr_addr_o : std_ulogic_vector(11 downto 0) >>;
  csr_wdata <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst.neorv32_cpu_control_inst.xcsr_wdata_o : std_ulogic_vector(31 downto 0) >>;
  csr_rdata_o <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst.neorv32_cpu_control_inst.csr_rdata_o : std_ulogic_vector(31 downto 0) >>;
  csr_valid <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst.neorv32_cpu_control_inst.csr_reg_valid : std_logic >>;

  main: process
  begin
    test_runner_setup(runner, runner_cfg);
    while test_suite loop
      if run("test") then
        set_log_handlers(logger, (display_handler, file_handler));
        show_all(logger, file_handler);
        show_all(logger, display_handler);

        rst <= '1';
        wait for 15*clk_period;
        rst <= '0';
        info(logger, "Init test");
        wait until rising_edge(clk);
        start <= true;
        wait until rising_edge(clk);
        start <= false;
        wait until (done and rising_edge(clk));
        info(logger, "Test done");
      end if;
    end loop;
    test_runner_cleanup(runner);
    wait;
  end process;

  mycycle_capture: process
  begin
    done <= false;
    wait until start and rising_edge(clk);
    for x in 0 to test_items-1 loop
      wait until rising_edge(clk) and csr_we = '0' and csr_valid = '1' and csr_addr = x"B00" and csr_rdata_o /= x"00000000"; -- CSR MYCYCLE ADDR IS 0xB00
      info(logger, "Data " & to_string(x+1) & "/" & to_string(test_items) & " latency is " & to_string(to_integer(unsigned(csr_rdata_o))-1) & " cycles"); -- Remove one cycle, see gh:stnolting/neorv32/issues/897
      wait until rising_edge(clk);
    end loop;
    
    wait until rising_edge(clk);
    done <= true;
    wait;
  end process;

end architecture;
\end{minted}
\caption{tb\_complex\_mults\_cfu.vhd}
\label{ap-cod:19}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- Authors:
--   Unai Martinez-Corral & Unai Sainz-Estebanez
--     <unai.martinezcorral@ehu.eus>
--     <usainz003@ikasle.ehu.eus>
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- SPDX-License-Identifier: Apache-2.0

library ieee;
context ieee.ieee_std_context;

library vunit_lib;
context vunit_lib.vunit_context;
context vunit_lib.vc_context;

entity mult_wfifos_axis_vcs is
  generic (
    m_axis : axi_stream_master_t;
    s_axis : axi_stream_slave_t;
    N_bits : natural := 32;
    Log2_elements : natural := 4;
    test_items : natural := 4;
    logger : logger_t
  );
  port (
    clk, rstn: in std_logic
  );
end entity;

architecture arch of mult_wfifos_axis_vcs is

  signal m_valid, m_ready, s_valid, s_ready : std_logic;
  signal m_data, s_data : std_logic_vector(data_length(m_axis)-1 downto 0);

begin

  vunit_axism: entity vunit_lib.axi_stream_master
  generic map (
    master => m_axis
  )
  port map (
    aclk   => clk,
    tvalid => m_valid,
    tready => m_ready,
    tdata  => m_data,
    tlast  => open
  );

  vunit_axiss: entity vunit_lib.axi_stream_slave
  generic map (
    slave => s_axis
  )
  port map (
    aclk   => clk,
    tvalid => s_valid,
    tready => s_ready,
    tdata  => s_data,
    tlast  => open
  );

--

  uut: entity work.mult_wfifos_axis
  generic map (
    N_bits => N_bits,
    Log2_elements => Log2_elements
  )
  port map (
    clk_mult => clk,
    s_axis_clk   => clk,
    s_axis_rstn  => rstn,
    s_axis_rdy   => m_ready,
    s_axis_data  => m_data,
    s_axis_valid => m_valid,
    m_axis_clk   => clk,
    m_axis_rstn  => rstn,
    m_axis_valid => s_valid,
    m_axis_data  => s_data,
    m_axis_rdy   => s_ready
  );

-- To extract time information through the INFO function, for latency measurements

  send_trigger: process
  begin

    for x in 0 to test_items-1 loop
      wait until rising_edge(clk) and m_valid = '1' and m_ready = '1';
      info(logger, "Data (" & to_string(m_data(31 downto 16)) & "x" & to_string(m_data(15 downto 0))  & ") " & to_string(x+1) & "/" & to_string(test_items) & " sent!");
    end loop;
  end process;

  received_trigger: process
  begin

    for x in 0 to test_items-1 loop
      wait until rising_edge(clk) and s_valid = '1' and s_ready = '1';
      info(logger, "Data (" & to_string(s_data) & ") " & to_string(x+1) & "/" & to_string(test_items) & " received!");
    end loop;
  end process;

end architecture;
\end{minted}
\caption{mult\_wfifos\_axis\_vcs.vhd}
\label{ap-cod:20}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- Authors:
--   Unai Martinez-Corral & Unai Sainz-Estebanez
--     <unai.martinezcorral@ehu.eus>
--     <usainz003@ikasle.ehu.eus>
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- SPDX-License-Identifier: Apache-2.0

library ieee;
context ieee.ieee_std_context;

library vunit_lib;
context vunit_lib.vunit_context;
context vunit_lib.vc_context;

entity tb_mult_wfifos_axis_latency is
  generic (
    runner_cfg : string
  );
end entity;

architecture tb of tb_mult_wfifos_axis_latency is

  -- Simulation constants

  constant clk_period : time    := 10 ns;
  constant data_width : natural := 32;

  -- AXI4Stream Verification Components

  constant master_axi_stream : axi_stream_master_t := new_axi_stream_master(
    data_length => data_width,
    stall_config => new_stall_config(0.0, 1, 10)
  );
  constant slave_axi_stream  : axi_stream_slave_t  := new_axi_stream_slave(
    data_length => data_width,
    stall_config => new_stall_config(0.0, 1, 10)
  );

  -- Logging

  constant logger : logger_t := get_logger("tb_mult_wfifos_axis_latency");
  constant file_handler : log_handler_t := new_log_handler(
    output_path(runner_cfg) & "log.csv",
    format => csv,
    use_color => false
  );

  -- tb signals and variables

  signal clk, rst, rstn : std_logic := '0';
  signal start, done : boolean := false;

  constant test_items : natural := 4;
  type test_t is array (0 to test_items-1, 0 to 2) of integer;
  constant test_data : test_t := (
    (1, 1, 1),
    (2, 2, 4),
    (4, 4, 16),
    (8, 8, 64)
  );

begin

  clk <= not clk after clk_period/2;
  rstn <= not rst;

  main: process
  begin
    test_runner_setup(runner, runner_cfg);
    while test_suite loop
      if run("test") then
        set_log_handlers(logger, (display_handler, file_handler));
        show_all(logger, file_handler);
        show_all(logger, display_handler);

        rst <= '1';
        wait for 15*clk_period;
        rst <= '0';
        info(logger, "Init test");
        wait until rising_edge(clk);
        start <= true;
        wait until rising_edge(clk);
        start <= false;
        wait until (done and rising_edge(clk));
        info(logger, "Test done");
      end if;
    end loop;
    test_runner_cleanup(runner);
    wait;
  end process;

  stimuli: process
    variable word : std_logic_vector(data_width-1 downto 0);
    variable o : std_logic_vector(31 downto 0);
    variable last : std_logic:='0';
  begin
    done <= false;
    wait until start and rising_edge(clk);

    for x in 0 to test_items-1 loop
      word(data_width-1 downto data_width/2) := std_logic_vector(to_signed(test_data(x, 0), data_width/2));
      word(data_width/2-1 downto 0) := std_logic_vector(to_signed(test_data(x, 1), data_width/2));
      push_axi_stream(net, master_axi_stream, word);
      pop_axi_stream(net, slave_axi_stream, tdata => o, tlast => last);
      check_equal(signed(o),to_signed(test_data(x,2), data_width),"This is a failure!");
    end loop;

    wait until rising_edge(clk);
    done <= true;
    wait;
  end process;

  uut_vc: entity work.mult_wfifos_axis_vcs
  generic map (
    m_axis => master_axi_stream,
    s_axis => slave_axi_stream,
    N_bits => data_width,
    Log2_elements => 3,
    test_items => test_items,
    logger => logger
  )
  port map (
    clk  => clk,
    rstn => rstn
  );

end architecture;
\end{minted}
\caption{tb\_mult\_wfifos\_axis\_latency.vhd}
\label{ap-cod:21}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{python}
#!/usr/bin/env python3

from _csv import Error, __version__, writer, reader, register_dialect
from pathlib import Path
import re
import types
import csv
import os

# This program reads the simulation output csv and displays the latency of the operations
# Run this script after running run.py

# The path of the folder where the csv files are located is defined
ROOT = Path(__file__).parent
csv_path = ROOT / "vunit_out" / "outcsv"

# To choose the design an environment variable is defined. 'mult' value by default.
DESIGN = os.environ.get("DESIGN","mult")

# Specify the csv output file according to envvar
if DESIGN == "mult":
    csv_file = csv_path / "tb_mult_wfifos_axis_latency.csv"
elif DESIGN == "multp-wfifos":
    csv_file = csv_path / "tb_multp_wfifos_axis_latency.csv"
elif DESIGN == "multp":
    csv_file = csv_path / "tb_multp_axis_latency.csv"
else:
    print("The valid envvar values are: mult, multp-wfifos and multp")
    exit()

# The lists are defined
time=[]
time_num=[]
line=[]
sent=[]
received=[]

# Function to open csv and read from it
with open(csv_file, newline='') as csvfile:
    # Reading function; ',' delimeter is selected
    csv_reader = csv.reader(csvfile, delimiter=',', quotechar='|')
    # Take the first value of the fourth column (Name of vhdl file where the csv comes from)    
    name=next(csv_reader)[3]
    # Reset the csv file handle
    csvfile.seek(0)
    # Loop through the csv file 
    for row in csv_reader:
        # Filling the time/line lists with the second column (time of the operations) and the fifth column (line where the operation comes from)
        time.append(row[1])
        line.append(row[4])

# Loop for remove " fs"
for i in range(0, len(time)):
    a=time[i]
    a=a.replace(" fs","")
    time_num.append(a)

# Define the matrix with the time and lines information
matrix = [time_num,line]

# Filling the sent and the received lists
# Note that to have the line information the vu.enable_location_preprocessing() function must be in the program run.py
for k in range(0,len(line)):
    if int(matrix[1][k]) == 100: # If the time information comes from line 99 is sent information
        sent.append(matrix[0][k]) # Save the sent time information
    elif int(matrix[1][k]) == 109: # If the time information comes from line 108 is received information
        received.append(matrix[0][k]) # Save the received time information

if len(sent) != len(received):
    print("Error: the sent length is not equal to the received length")
    exit()

# Print the name of vhdl file where the csv comes from
print("---- For",name,"file ----")

# Loop for display the latency of the operations
for z in range(0,len(sent)):
    # Casting from string to integer
    k = int(received[z]) - int(sent[z])
    if z == 0:
        print("The latency is:",k,"fs -",int(k/10000000),"cycles")
    # Send/received data latency
    print("Data",z+1,"of",len(sent),"sent/received latency is:",k,"fs -",int(k/10000000),"cycles")
\end{minted}
\caption{latency.py}
\label{ap-cod:22}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{bash}
#!/usr/bin/env bash

set -ex

cd $(dirname "$0")

if [[ -z "${Board}" ]]; then
  Arty='35t'
elif [[ $Board == '35t' ]]; then
  Arty='35t'
elif [[ $Board == '100t' ]]; then
  Arty='100t'
else
  echo "Error Board must be 35t or 100t"
  exit
fi
echo "Selected board is" $Arty

apt update -qq

apt install -y git

cd ../..

git clone --recursive https://github.com/stnolting/neorv32-setups

mv rtl/mult/CFU/neorv32_application_image.vhd neorv32-setups/neorv32/rtl/core
mv rtl/mult/CFU/neorv32_cpu_cp_cfu.vhd neorv32-setups/neorv32/rtl/core

mkdir -p build

echo "Analyze NEORV32 CPU + MULT(P) via CFU"

ghdl -i --std=08 --workdir=build --work=neorv32  ./neorv32-setups/neorv32/rtl/core/*.vhd
ghdl -i --std=08 --workdir=build --work=neorv32  ./neorv32-setups/neorv32/rtl/core/mem/neorv32_dmem.default.vhd
ghdl -i --std=08 --workdir=build --work=neorv32  ./neorv32-setups/neorv32/rtl/core/mem/neorv32_imem.default.vhd
ghdl -i --std=08 --workdir=build --work=neorv32 ./rtl/mult/*.vhd
ghdl -i --std=08 --workdir=build --work=neorv32 ./rtl/multp/*.vhd
ghdl -i --std=08 --workdir=build --work=neorv32 ./rtl/mult/CFU/neorv32_mults_cfu.vhd
ghdl -m --std=08 --workdir=build --work=neorv32 neorv32_mults_cfu

echo "Synthesis with yosys and ghdl as module"

yosys -m ghdl -p 'ghdl --std=08 --workdir=build --work=neorv32 neorv32_mults_cfu; synth_xilinx -nodsp -nolutram -flatten -abc9 -arch xc7 -top neorv32_mults_cfu; write_json neorv32_mults_cfu.json' 

if [[ $Arty == '35t' ]]; then
  echo "Place and route"
  nextpnr-xilinx --chipdb /usr/local/share/nextpnr/xilinx-chipdb/xc7a35t.bin --xdc impl/nextpnr/arty.xdc --json neorv32_mults_cfu.json --write neorv32_mults_cfu_routed.json --fasm neorv32_mults_cfu.fasm
  echo "Generate bitstream"
  ../../prjxray/utils/fasm2frames.py --part xc7a35tcsg324-1 --db-root /usr/local/share/nextpnr/prjxray-db/artix7 neorv32_mults_cfu.fasm > neorv32_mults_cfu.frames
  ../../prjxray/build/tools/xc7frames2bit --part_file /usr/local/share/nextpnr/prjxray-db/artix7/xc7a35tcsg324-1/part.yaml --part_name xc7a35tcsg324-1 --frm_file neorv32_mults_cfu.frames --output_file neorv32_mults_cfu_35t.bit
elif [[ $Arty == '100t' ]]; then
  echo "Place and route"
  nextpnr-xilinx --chipdb /usr/local/share/nextpnr/xilinx-chipdb/xc7a100t.bin --xdc impl/nextpnr/arty.xdc --json neorv32_mults_cfu.json --write neorv32_mults_cfu_routed.json --fasm neorv32_mults_cfu.fasm
  echo "Generate bitstream"
  ../../prjxray/utils/fasm2frames.py --part xc7a100tcsg324-1 --db-root /usr/local/share/nextpnr/prjxray-db/artix7 neorv32_mults_cfu.fasm > neorv32_mults_cfu.frames
  ../../prjxray/build/tools/xc7frames2bit --part_file /usr/local/share/nextpnr/prjxray-db/artix7/xc7a100tcsg324-1/part.yaml --part_name xc7a100tcsg324-1 --frm_file neorv32_mults_cfu.frames --output_file neorv32_mults_cfu_100t.bit
fi

echo "Implementation completed"
\end{minted}
\caption{impl\_mults\_cfu.sh}
\label{ap-cod:23}
\end{code}
