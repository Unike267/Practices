
\chapter{Código} % Título del Anexo

\label{Codigo} % Etiqueta \ref{Planos}

El código empleado a lo largo de este trabajo es bastante extenso.
Comprende desde la descripción hardware en VHDL de los diseños y los \textit{test benches}, pasando por la codificación de software en C, archivos en Python para lanzar las simulaciones de VUnit, así como para gestionar sus archivos de salida en formato csv, además de archivos Yml para gestionar la integración continua, archivos Bash para gestionar la generación de \textit{bitstream} mediante herramientas FLOS y archivos Tcl para gestionar la generación de \textit{bitstream} mediante Vivado. 
El total del código empleado está en el repositorio de GitLab del grupo de investigación y gran parte de él, sobre todo el referente a la sección \ref{Carac}, está en el siguiente repositorio público de GitHub \cite{gh:practices}.
Este apéndice comprende parte del código desarrollado como ejemplificación del trabajo realizado a lo largo de este proyecto de investigación.

%\begin{code}
%\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}

%\end{minted}
%\caption{}
%\label{ap-cod:}
%\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,linenos]{vhdl}
-- RTL of MULT

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity mult is
generic (  
        -- Number of bits that the input/output data has. 
        N_bits : in natural
        );
port (
        -- Clock signal
        clk : in std_logic;
        -- Mult in/out signals
        mult_in : in std_logic_vector (N_bits-1 downto 0);
        mult_out : out std_logic_vector(N_bits-1 downto 0)
     );
end mult;

architecture rtl of mult is

-- Declaration of signals

signal in_1 : unsigned ((N_bits/2)-1 downto 0) := (others => '0');
signal in_2 : unsigned ((N_bits/2)-1 downto 0) := (others => '0');

begin
  
    -- Assign inputs to the multipler 

    in_1 <= unsigned(mult_in(N_bits-1 downto N_bits/2));
    in_2 <= unsigned(mult_in((N_bits/2)-1 downto 0));

    -- Make multiplication and assign output

    mult_make : process ( clk )
        begin
            if( rising_edge (clk) ) then
                mult_out <= std_logic_vector(in_1 * in_2);
            end if;
    end process mult_make;

end rtl;
\end{minted}
\caption{Mult.vhd}
\label{ap-cod:1}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- RTL of FIFO

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity fifo is
generic (  
        -- Number of bits per element 
        N_bits : in natural;
        -- Log2 of number of elements that the FIFO has; Number of FIFO elements has to be a power of two.
        Log2_elements : in natural
        );
port (
        -- Fifo clocks/reset signals        
        clk_wr : in std_logic;
        clk_rd : in std_logic;
        rst : in std_logic;
        -- Fifo in/out signals
        fifo_in : in std_logic_vector (N_bits-1 downto 0);
        fifo_out : out std_logic_vector(N_bits-1 downto 0);
        -- Fifo write/read signals
        wr : in std_logic;
        rd : in std_logic;
        -- Fifo status signals
        full_o : out std_logic;
        empty_o : out std_logic
     );
end fifo;

architecture rtl of fifo is

-- Declariation of fifo array

type array_type is array ((2**Log2_elements)-1 downto 0) of std_logic_vector(N_bits-1 downto 0);
signal fifo_array : array_type := (others => (others => '0'));

-- Declaration of signals

signal wr_pnt : std_logic_vector(Log2_elements downto 0) := (others => '0');
signal rd_pnt : std_logic_vector(Log2_elements downto 0) := (others => '0');
signal full : std_logic := '0';
signal empty : std_logic := '0';


begin

    -- Signals empty and full logic
    
    full_logic : process ( wr_pnt,rd_pnt )
    begin   
        if( (wr_pnt(Log2_elements-1 downto 0) = rd_pnt(Log2_elements-1 downto 0)) and ( (wr_pnt(wr_pnt'left) xor rd_pnt(rd_pnt'left)) = '1') ) then
            full <= '1';
        else
            full <= '0';
        end if;
    end process full_logic;    

    empty_logic : process ( wr_pnt,rd_pnt )  
    begin
        if ( wr_pnt = rd_pnt ) then
            empty <= '1';
        else
            empty <= '0';
        end if;
    end process empty_logic;

    -- Assign control signals output

    full_o <= full;
    empty_o <= empty;

    -- Write and read process

    write_process: process (clk_wr)
    begin
        if( rising_edge( clk_wr ) ) then
            if( rst = '1' ) then
                wr_pnt <= (others => '0');
            elsif( wr = '1' and full = '0' ) then
                fifo_array(to_integer(unsigned(wr_pnt(Log2_elements-1 downto 0)))) <= fifo_in;
                wr_pnt <= std_logic_vector(unsigned(wr_pnt) + 1);
            end if;                 
        end if;
    end process write_process;

    read_process: process (clk_rd)
    begin
        if( rising_edge( clk_rd ) ) then
            if( rst = '1' ) then
                rd_pnt <= (others => '0');
                fifo_out <= (others => '0');
            elsif( rd = '1' and empty = '0' ) then
                fifo_out <= fifo_array(to_integer(unsigned(rd_pnt(Log2_elements-1 downto 0))));
                rd_pnt <= std_logic_vector(unsigned(rd_pnt) + 1);
            end if;                 
        end if;
    end process read_process;

end rtl;
\end{minted}
\caption{fifo.vhd}
\label{ap-cod:2}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- RTL of Mult_wfifos

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity mult_wfifos is
generic (
        -- Number of bits that the input/output data has
        N_bits : in natural;
        -- Log2 of number of elements that the FIFOs have; Both the same size; Number of FIFO elements has to be a power of two
        Log2_elements : in natural
        );
port (
        -- Mult_wfifos clocks and reset signals
        clk_wr : in std_logic;
        clk_mult : in std_logic;
        clk_rd : in std_logic;
        rst : in std_logic;
        -- Mult_wfifos input/output data
        din : in std_logic_vector (N_bits-1 downto 0);
        dout : out std_logic_vector (N_bits-1 downto 0);
        -- Mult_wfifos write and read signals;
        wr : in std_logic;
        rd : in std_logic;
        -- Mult_wfifos status signals
        full : out std_logic;
        empty : out std_logic
);
end mult_wfifos;

architecture rtl of mult_wfifos is

-- Declaration of signals
signal in_pre_mult : std_logic_vector(N_bits-1 downto 0) := (others => '0');
signal in_post_mult : std_logic_vector(N_bits-1 downto 0) := (others => '0');
signal rd_inter : std_logic := '0';
signal wr_inter : std_logic := '0';
signal empty_inter : std_logic := '0';
signal full_inter : std_logic := '0';

type t_states is (CHECK,READ,MULTI,WRITE);
signal state : t_states := CHECK;
signal next_state : t_states;


begin

-- Fifo IN instantiation

fifo_IN : entity work.fifo
                generic map (N_bits => N_bits,
                             Log2_elements => Log2_elements)
                port map (clk_wr => clk_wr,
                          clk_rd => clk_mult,
                          rst => rst,
                          fifo_in => din,
                          fifo_out => in_pre_mult,
                          wr => wr,
                          rd => rd_inter,
                          full_o => full,
                          empty_o => empty_inter);

-- mult instantiation

mult_0 : entity  work.mult
                generic map (N_bits => N_bits)
                port map (clk => clk_mult,
                          mult_in => in_pre_mult,
                          mult_out => in_post_mult);

-- Fifo OUT instantiation

fifo_OUT : entity work.fifo
                generic map (N_bits => N_bits,
                             Log2_elements => Log2_elements)
                port map (clk_wr => clk_mult,
                          clk_rd => clk_rd,
                          rst => rst,
                          fifo_in => in_post_mult,
                          fifo_out => dout,
                          wr => wr_inter,
                          rd => rd,
                          full_o => full_inter,
                          empty_o => empty);

-- State machine
    -- Combinational

    Combinational_of_state_machine : process (state, empty_inter, full_inter)
    begin
        next_state <= state;
        case state is
            when CHECK =>
                if (empty_inter = '0' and full_inter = '0') then
                    next_state <= READ;
                else
                    next_state <= CHECK;
                end if;
            when READ =>
                next_state <= MULTI;
            when MULTI =>
                next_state <= WRITE;
            when WRITE =>
                next_state <= CHECK;
            when others =>
                next_state <= CHECK;
        end case;
    end process Combinational_of_state_machine;

    -- Outputs

    with state select
        wr_inter <= '1' when WRITE,
                    '0' when others;
    with state select
        rd_inter <= '1' when READ,
                    '0' when others;

    -- Sequential

    state_machine_state_reg : process ( clk_mult )
    begin
        if( rising_edge(clk_mult) ) then
            if( rst = '1' ) then
                state <= CHECK;
            else
                state <= next_state;
            end if;
        end if;
    end process state_machine_state_reg;

end rtl;
\end{minted}
\caption{Mult\_wfifos.vhd}
\label{ap-cod:3}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- RTL of mult_axis

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity mult_wfifos_axis is
generic (
        -- Number of bits that the input/output data has
        N_bits : in natural;
        -- Log2 of number of elements that the FIFOs have; Both the same size; Number of FIFO elements has to be a power of two
        Log2_elements : in natural
        );
port (
    -- Clk mult
    clk_mult : in std_logic;

    -- Slave signals
    s_axis_clk   : in  std_logic;
    s_axis_rstn  : in  std_logic;
    s_axis_rdy   : out std_logic;
    s_axis_data  : in  std_logic_vector(N_bits-1 downto 0);
    s_axis_valid : in  std_logic;

    -- Master signals
    m_axis_clk   : in  std_logic;
    m_axis_rstn  : in  std_logic;
    m_axis_valid : out std_logic;
    m_axis_data  : out std_logic_vector(N_bits-1 downto 0);
    m_axis_rdy   : in  std_logic
    );
end mult_wfifos_axis;

architecture rtl of mult_wfifos_axis is

signal reset, write, read, valid, empty, full : std_logic;

begin

-- Mult_wfifos instantation

mult_wfifos_0 : entity work.mult_wfifos
                generic map (N_bits => N_bits,
                             Log2_elements => Log2_elements)
                port map (clk_wr => s_axis_clk,
                          clk_mult => clk_mult,
                          clk_rd => m_axis_clk,
                          rst => reset,
                          din => s_axis_data,
                          dout => m_axis_data,
                          wr => write,
                          rd => read,
                          full => full,
                          empty => empty);

-- Reset (NEORV32 rst is low-active)

reset <= (s_axis_rstn nand m_axis_rstn);

-- Write and read signals

write <= s_axis_valid and not(full);

read <= not(empty) and (valid nand not(m_axis_rdy));

-- Make valid signal

make_valid : process(m_axis_clk) begin
    if rising_edge(m_axis_clk) then
        if (((not m_axis_rstn) or ((valid and empty) and m_axis_rdy)) = '1') then
            valid <= '0';
        elsif (read = '1') then
            valid <= '1';
        end if;
    end if;
    end process make_valid;

-- Assing axi signals

s_axis_rdy <= not(full);
m_axis_valid <= valid;

end rtl;
\end{minted}
\caption{mult\_wfifos\_axis.vhd}
\label{ap-cod:4}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- RTL of mult_wfifos_wishbone

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity mult_wfifos_wishbone is
generic (  
        -- Number of bits that the input/output data has
        N_bits : in natural;
        -- Log2 of number of elements that the FIFOs have; Both the same size; Number of FIFO elements has to be a power of two
        Log2_elements : in natural
        );
port (
    rst_i : in std_logic;
    clk_i : in std_logic;
    adr_i : in std_logic_vector(31 downto 0);
    dat_i : in std_logic_vector(31 downto 0);
    dat_o : out std_logic_vector(31 downto 0);
    we_i : in std_logic;
    sel_i : in std_logic_vector(3 downto 0);
    stb_i : in std_logic;
    ack_o : out std_logic;
    cyc_i : in std_logic;
    err_o : out std_logic;
    stall_o : out std_logic
    );
end mult_wfifos_wishbone;

architecture rtl of mult_wfifos_wishbone is

signal reset, write, read, empty, full : std_logic;
signal ack : std_logic;
signal stall : std_logic;
signal input : std_logic_vector(31 downto 0);
signal output : std_logic_vector(31 downto 0);
signal transfer_in : std_logic;
signal transfer_out : std_logic;
signal output_window : std_logic := '0';

begin

-- Mult_wfifos instantation

mult_wfifos_0 : entity work.mult_wfifos
                generic map (N_bits => N_bits,
                             Log2_elements => Log2_elements)
                port map (clk_wr => clk_i,
                          clk_mult => clk_i,
                          clk_rd => clk_i,
                          rst => reset,
                          din => input,
                          dout => output,
                          wr => write,
                          rd => read,
                          full => full,
                          empty => empty);

-- Reset (NEORV32 rst is low-active)

reset <= not rst_i;

-- Make error signal

err_o <= '0'; --tie to zero if not explicitly used

-- Make stall signal

with we_i select 
     stall <= full  when '1',
              empty when others;

stall_o <= stall;

-- Make transfer in/out signals

transfer_in  <= (stb_i and cyc_i and we_i and not(stall)) when adr_i = x"90000000" else  -- The address is 0x90000000; See main.c in sw/EMEM
                '0';

transfer_out <= (stb_i and cyc_i and not(we_i) and not(stall)) when adr_i = x"90000000" else
                '0';

-- Manage input/output and write/read signals

with transfer_in select
     input <= dat_i when '1',
              (others => '0') when others;

with transfer_in select
     write <= '1' when '1',
              '0' when others;

with transfer_out select
     read  <= '1' when '1',
              '0' when others;

with output_window select
     dat_o <= output when '1',
              (others => '0') when others;

-- Manage output_window

process (clk_i) begin
    if rising_edge(clk_i) then
      if reset = '1' then
        output_window <= '0';
      elsif transfer_out = '1' then
        output_window <= '1';
      else
        output_window <= '0';
      end if;
    end if;
end process;

-- Manage ack signal

process (clk_i) begin
    if rising_edge(clk_i) then
      if reset = '1' then
        ack <= '0';
      else
        if transfer_in or transfer_out then
          ack <= '1';
        else
          ack <= '0';
        end if;
      end if;
    end if;
  end process;
                
ack_o <= ack;

end rtl;
\end{minted}
\caption{mult\_wfifos\_wishbone.vhd}
\label{ap-cod:5}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- Authors:
--   Unai Martinez-Corral & Unai Sainz-Estebanez
--     <unai.martinezcorral@ehu.eus>
--     <usainz003@ikasle.ehu.eus>
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- SPDX-License-Identifier: Apache-2.0

library ieee;
context ieee.ieee_std_context;

entity multp_op is
  generic (
    g_data_width : natural
  );
  port (
    DIN : in std_logic_vector (g_data_width-1 downto 0);
    DOUT : out std_logic_vector(g_data_width-1 downto 0)
  );
end multp_op;

architecture arch of multp_op is
begin

  DOUT <= std_logic_vector(
    signed(DIN(g_data_width-1 downto g_data_width/2))
    *
    signed(DIN((g_data_width/2)-1 downto 0))
  );

end arch;


library ieee;
context ieee.ieee_std_context;

entity multp is
  generic (
    g_data_width : natural
  );
  port (
    CLK : in std_logic;
    RST : in std_logic;
    IN_VALID : in std_logic;
    IN_READY : out std_logic;
    DIN : in std_logic_vector (g_data_width-1 downto 0);
    OUT_VALID : out std_logic;
    OUT_READY : in std_logic;
    DOUT : out std_logic_vector(g_data_width-1 downto 0)
  );
end multp;

architecture registered of multp is

  signal ready: std_logic;
  signal valid : std_logic;
  signal transfer_in : std_logic;
  signal transfer_out : std_logic;
  signal result : std_logic_vector(g_data_width-1 downto 0);

begin

  transfer_in <= IN_VALID and ready;
  transfer_out <= valid and OUT_READY;
  ready <= not rst and ((not valid) or transfer_out);

  IN_READY <= ready;
  OUT_VALID <= valid;

  i_multp_op : entity work.multp_op
    generic map (
      g_data_width => g_data_width
    )
    port map (
      DIN  => DIN,
      DOUT => result
    );

  process (CLK) begin
    if rising_edge(CLK) then
      if RST then
        DOUT <= (others=>'0');
      elsif transfer_in then
        DOUT <= result;
      end if;
    end if;
  end process;

  process (CLK) begin
    if rising_edge(CLK) then
      if RST then
        valid <= '0';
      else
        if transfer_in then
          valid <= '1';
        elsif transfer_out then
          valid <= '0';
        end if;
      end if;
    end if;
  end process;

end registered;

architecture combinatorial of multp is

begin

  IN_READY <= OUT_READY;
  OUT_VALID <= IN_VALID;

  i_multp_op : entity work.multp_op
    generic map (
      g_data_width => g_data_width
    )
    port map (
      DIN  => DIN,
      DOUT => DOUT
    );

end combinatorial;
\end{minted}
\caption{multp.vhd}
\label{ap-cod:6}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- Authors:
--   Unai Martinez-Corral & Unai Sainz-Estebanez
--     <unai.martinezcorral@ehu.eus>
--     <usainz003@ikasle.ehu.eus>
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- SPDX-License-Identifier: Apache-2.0

library ieee;
context ieee.ieee_std_context;

entity multp_wfifos is
  generic (
    g_data_width : natural := 32;
    g_fifo_depth : natural := 0 -- ceiling of the log base 2 of the desired FIFO length
  );
  port (
     CLK_IN   : in std_logic;
     CLK_MULT : in std_logic;
     CLK_OUT  : in std_logic;
     RST      : in std_logic;
     DIN      : in std_logic_vector (g_data_width-1 downto 0);
     DOUT     : out std_logic_vector (g_data_width-1 downto 0);
     WRITE    : in std_logic;
     READ     : in std_logic;
     FULL     : out std_logic;
     EMPTY    : out std_logic
);
end multp_wfifos;

architecture rtl of multp_wfifos is

  signal data_in    : std_logic_vector(g_data_width-1 downto 0);
  signal data_out   : std_logic_vector(g_data_width-1 downto 0);
  signal i_read     : std_logic;
  signal i_write    : std_logic;
  signal i_empty    : std_logic;
  signal i_full     : std_logic;
  signal in_valid   : std_logic;
  signal in_ready   : std_logic;
  signal out_valid  : std_logic;
  signal out_ready  : std_logic;

begin

  fifo_in : entity work.fifo
    generic map (
      N_bits => g_data_width,
      Log2_elements => g_fifo_depth)
    port map (
      clk_wr => CLK_IN,
      clk_rd => CLK_MULT,
      rst => RST,
      fifo_in => DIN,
      fifo_out => data_in,
      wr => WRITE,
      rd => i_read,
      full_o => FULL,
      empty_o => i_empty
    );

  i_read <= in_ready and not i_empty;

  process (CLK_MULT) begin
    if rising_edge(CLK_MULT) then
      if RST then
        in_valid <= '0';
      else
        in_valid <= i_read;
      end if;
    end if;
  end process;

  multp : entity work.multp(combinatorial)
    generic map (
      g_data_width => g_data_width
    )
    port map (
      CLK => CLK_MULT,
      RST => RST,
      IN_VALID => in_valid,
      IN_READY => in_ready,
      DIN => data_in,
      OUT_VALID => out_valid,
      OUT_READY => out_ready,
      DOUT => data_out
    );

  i_write <= out_valid and out_ready;
  out_ready <= not i_full;

  fifo_out : entity work.fifo
    generic map (
      N_bits => g_data_width,
      Log2_elements => g_fifo_depth
    )
    port map (
      clk_wr => CLK_MULT,
      clk_rd => CLK_OUT,
      rst => RST,
      fifo_in => data_out,
      fifo_out => DOUT,
      wr => i_write,
      rd => READ,
      full_o => i_full,
      empty_o => EMPTY
    );

end rtl;
\end{minted}
\caption{multp\_wfifos.vhd}
\label{ap-cod:7}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- Authors:
--   Unai Martinez-Corral & Unai Sainz-Estebanez
--     <unai.martinezcorral@ehu.eus>
--     <usainz003@ikasle.ehu.eus>
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- SPDX-License-Identifier: Apache-2.0

library ieee;
context ieee.ieee_std_context;

entity multp_wfifos_axis is
  generic (
    g_data_width : natural := 32;
    g_fifo_depth : natural := 0 -- ceiling of the log base 2 of the desired FIFO length
  );
  port (
    CLK_MULT     : in std_logic;
    s_axis_clk   : in  std_logic;
    s_axis_rstn  : in  std_logic;
    s_axis_rdy   : out std_logic;
    s_axis_data  : in  std_logic_vector(g_data_width-1 downto 0);
    s_axis_valid : in  std_logic;
    m_axis_clk   : in  std_logic;
    m_axis_rstn  : in  std_logic;
    m_axis_valid : out std_logic;
    m_axis_data  : out std_logic_vector(g_data_width-1 downto 0);
    m_axis_rdy   : in  std_logic
  );
end multp_wfifos_axis;

architecture rtl of multp_wfifos_axis is

signal read, empty, full, valid : std_logic;

begin

  s_axis_rdy <= not full;

  i_multp_wfifos : entity work.multp_wfifos
    generic map (
      g_data_width => g_data_width,
      g_fifo_depth => g_fifo_depth
    )
    port map (
      CLK_IN   => s_axis_clk,
      CLK_MULT => clk_mult,
      CLK_OUT  => m_axis_clk,
      RST      => s_axis_rstn nand m_axis_rstn,
      DIN      => s_axis_data,
      DOUT     => m_axis_data,
      WRITE    => s_axis_valid and not full,
      READ     => read,
      FULL     => full,
      EMPTY    => empty
    );

  read <= (valid nand not m_axis_rdy) and not empty;

  process (m_axis_clk) begin
    if rising_edge(m_axis_clk) then
      if (not m_axis_rstn) or ((valid and empty) and m_axis_rdy) then
        valid <= '0';
      elsif read then
        valid <= '1';
      end if;
    end if;
  end process;

  m_axis_valid <= valid;

end rtl;
\end{minted}
\caption{multp\_wfifos\_axis.vhd}
\label{ap-cod:8}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- RTL of multp_wfifos_wishbone

library ieee;
context ieee.ieee_std_context;

entity multp_wfifos_wishbone is
generic (  
        -- Number of bits that the input/output data has
        N_bits : in natural;
        -- Log2 of number of elements that the FIFOs have; Both the same size; Number of FIFO elements has to be a power of two
        Log2_elements : in natural
        );
port (
    rst_i : in std_logic;
    clk_i : in std_logic;
    adr_i : in std_logic_vector(31 downto 0);
    dat_i : in std_logic_vector(31 downto 0);
    dat_o : out std_logic_vector(31 downto 0);
    we_i : in std_logic;
    sel_i : in std_logic_vector(3 downto 0);
    stb_i : in std_logic;
    ack_o : out std_logic;
    cyc_i : in std_logic;
    err_o : out std_logic;
    stall_o : out std_logic
    );
end multp_wfifos_wishbone;

architecture rtl of multp_wfifos_wishbone is

signal reset, write, read, empty, full : std_logic;
signal ack : std_logic;
signal stall : std_logic;
signal input : std_logic_vector(31 downto 0);
signal output : std_logic_vector(31 downto 0);
signal transfer_in : std_logic;
signal transfer_out : std_logic;
signal output_window : std_logic := '0';

begin

-- Multp_wfifos instantation

multp_wfifos_0 : entity work.multp_wfifos
                 generic map (g_data_width => N_bits,
                              g_fifo_depth => Log2_elements)
                 port map (clk_in => clk_i,
                           clk_mult => clk_i,
                           clk_out => clk_i,
                           rst => reset,
                           din => input,
                           dout => output,
                           write => write,
                           read => read,
                           full => full,
                           empty => empty);

-- Reset (NEORV32 rst is low-active)

reset <= not rst_i;

-- Make error signal

err_o <= '0'; --tie to zero if not explicitly used

-- Make stall signal

with we_i select 
     stall <= full  when '1',
              empty when others;

stall_o <= stall;

-- Make transfer in/out signals

transfer_in  <= (stb_i and cyc_i and we_i and not(stall)) when adr_i = x"90000000" else  -- The address is 0x90000000; See main.c in sw/EMEM
                '0';

transfer_out <= (stb_i and cyc_i and not(we_i) and not(stall)) when adr_i = x"90000000" else
                '0';

-- Manage input/output and write/read signals

with transfer_in select
     input <= dat_i when '1',
              (others => '0') when others;

with transfer_in select
     write <= '1' when '1',
              '0' when others;

with transfer_out select
     read  <= '1' when '1',
              '0' when others;

with output_window select
     dat_o <= output when '1',
              (others => '0') when others;

-- Manage output_window

process (clk_i) begin
    if rising_edge(clk_i) then
      if reset = '1' then
        output_window <= '0';
      elsif transfer_out = '1' then
        output_window <= '1';
      else
        output_window <= '0';
      end if;
    end if;
end process;

-- Manage ack signal

process (clk_i) begin
    if rising_edge(clk_i) then
      if reset = '1' then
        ack <= '0';
      else
        if transfer_in or transfer_out then
          ack <= '1';
        else
          ack <= '0';
        end if;
      end if;
    end if;
  end process;
                
ack_o <= ack;

end rtl;
\end{minted}
\caption{multp\_wfifos\_wishbone.vhd}
\label{ap-cod:9}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- RTL of multp

library ieee;
context ieee.ieee_std_context;

entity multp_wishbone is
generic (  
        -- Number of bits that the input/output data has
        N_bits : in natural
        );
port (
    rst_i : in std_logic;
    clk_i : in std_logic;
    adr_i : in std_logic_vector(31 downto 0);
    dat_i : in std_logic_vector(31 downto 0);
    dat_o : out std_logic_vector(31 downto 0);
    we_i : in std_logic;
    sel_i : in std_logic_vector(3 downto 0);
    stb_i : in std_logic;
    ack_o : out std_logic;
    cyc_i : in std_logic;
    err_o : out std_logic;
    stall_o : out std_logic
    );
end multp_wishbone;

architecture rtl of multp_wishbone is

signal reset : std_logic;
signal ack : std_logic;
signal input : std_logic_vector(31 downto 0);
signal output : std_logic_vector(31 downto 0);
signal transfer_in : std_logic;
signal transfer_out : std_logic;

begin

-- Multp instantation

multp_0 : entity work.multp_op
                 generic map (g_data_width => N_bits)
                 port map (din => input,
                           dout => output);

-- Reset (NEORV32 rst is low-active)

reset <= not rst_i;

-- Make error signal

err_o <= '0'; --tie to zero if not explicitly used

-- Make stall signal

stall_o <= '0';

-- Make transfer in/out signals

transfer_in  <= (stb_i and cyc_i and we_i) when adr_i = x"90000000" else -- The address is 0x90000000; See main.c in sw/EMEM
                '0';

transfer_out <= (stb_i and cyc_i and not(we_i)) when adr_i = x"90000000" else
                '0';

-- Manage inputs/outputs

process (clk_i) begin
    if rising_edge(clk_i) then
      if reset = '1' then
        input <= (others=>'0');
        dat_o <= (others=>'0');
      elsif transfer_in then
        input <= dat_i;
        dat_o <= (others=>'0');
      elsif transfer_out then
        dat_o <= output;
      else
        dat_o <= (others=>'0');
      end if;
    end if;
end process;

-- Make ack signal

process (clk_i) begin
    if rising_edge(clk_i) then
      if reset = '1' then
        ack <= '0';
      else
        if transfer_in or transfer_out then
          ack <= '1';
        else
          ack <= '0';
        end if;
      end if;
    end if;
  end process;

ack_o <= ack;

end rtl;
\end{minted}
\caption{multp\_wishbone.vhd}
\label{ap-cod:10}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{c}
#include <neorv32.h>
#include <string.h>

#define BAUD_RATE 19200

// This defines is used to bypass the intermediate print functions between axi functions (for latency and throughput measurements)
// Comment these defines to perform a normal execution
// Uncomment latency to perform latency measurements
// Uncomment throughput to perform throughput measurements
//#define latency
//#define throughput

int main() {

  // Capture all exceptions and give debug info via UART0
  neorv32_rte_setup();

  // Setup UART at default baud rate, no interrupts
  neorv32_uart0_setup(BAUD_RATE, 0);

  // Check if UART0 unit is implemented at all
  if (neorv32_uart0_available() == 0) {
    return -1; // abort if not implemented
  }

  // check if the CPU base counters are implemented
  if ((neorv32_cpu_csr_read(CSR_MXISA) & (1 << CSR_MXISA_ZICNTR)) == 0) {
    neorv32_uart0_printf("ERROR! Base counters ('Zicntr' ISA extensions) not implemented!\n");
    return -1;
  }

  // check if SLINK is implemented at all
  if (neorv32_slink_available() == 0) {
    neorv32_uart0_printf("ERROR! SLINK module not implemented.");
    return -1;
  }

  // setup SLINK module
  neorv32_slink_setup(0, 0);

  // Declaration of variables 
  //0000000000000001 x 0000000000000001
  static uint32_t fir = 0x00010001;
  //0000000000000010 x 0000000000000010
  static uint32_t sec = 0x00020002;
  //0000000000000100 x 0000000000000100
  static uint32_t thi = 0x00040004;
  //0000000000001000 x 0000000000001000
  static uint32_t fou = 0x00080008;

#ifdef latency
  // Intro
  neorv32_uart0_printf("\n A-lat \n\n");
  // Write 4 inputs to mult and read the outputs from mult one by one
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_slink_put(fir);
    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_slink_put(sec);
    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_slink_put(thi);
    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_slink_put(fou);
    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE); 

  // End
  neorv32_uart0_printf("\nEND-lat\n");
  #elif defined throughput
  // Intro
  neorv32_uart0_printf("\n A-thr \n\n");
  // Write 4 inputs to mult

    neorv32_slink_put(fir);

    neorv32_slink_put(sec);

    neorv32_slink_put(thi);

    neorv32_slink_put(fou);

  // Read outputs from mult

    neorv32_slink_get();
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);

    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE);

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_slink_get();
    neorv32_cpu_csr_read(CSR_MCYCLE);

  // End
  neorv32_uart0_printf("\nEND-thr\n");
  #else
  int i, slink_rc;;
  // show SLINK FIFO configuration
  int rx_depth = neorv32_slink_get_rx_fifo_depth();
  int tx_depth = neorv32_slink_get_tx_fifo_depth();
  // Intro
  neorv32_uart0_printf("\n<<< MULT(P) via slink (AXI-Stream) demo program >>>\n\n");
  neorv32_uart0_printf("RX FIFO depth: %u\n"
                       "TX FIFO depth: %u\n\n",
                       rx_depth, tx_depth);
  neorv32_uart0_printf("-------- Write data to MULT(P) --------\n");
  // Write 4 inputs to mult
    for (i=0; i<4 ; i++) {
    if(i==0){
            neorv32_uart0_printf("[%i] Sending 0x%x... ", i, fir);
            slink_rc = neorv32_slink_tx_status();
                if (slink_rc == SLINK_FIFO_FULL) {
                        neorv32_uart0_printf("FAILED! TX FIFO full!\n");
                        break;
                }
                else {
                        neorv32_slink_put(fir);
                        neorv32_uart0_printf("ok\n");
                     }
            } 
    if(i==1){
            neorv32_uart0_printf("[%i] Sending 0x%x... ", i, sec);
            slink_rc = neorv32_slink_tx_status();
                if (slink_rc == SLINK_FIFO_FULL) {
                        neorv32_uart0_printf("FAILED! TX FIFO full!\n");
                        break;
                }
                else {
                        neorv32_slink_put(sec);
                        neorv32_uart0_printf("ok\n");
                     }
            }   
    if(i==2){
            neorv32_uart0_printf("[%i] Sending 0x%x... ", i, thi);
            slink_rc = neorv32_slink_tx_status();
                if (slink_rc == SLINK_FIFO_FULL) {
                        neorv32_uart0_printf("FAILED! TX FIFO full!\n");
                        break;
                }
                else {
                        neorv32_slink_put(thi);
                        neorv32_uart0_printf("ok\n");
                     }
            }   
    if(i==3){
            neorv32_uart0_printf("[%i] Sending 0x%x... ", i, fou);
            slink_rc = neorv32_slink_tx_status();
                if (slink_rc == SLINK_FIFO_FULL) {
                        neorv32_uart0_printf("FAILED! TX FIFO full!\n");
                        break;
                }
                else {
                        neorv32_slink_put(fou);
                        neorv32_uart0_printf("ok\n");
                     }
            }   
    } 
  neorv32_uart0_printf("\n-------- Read data from MULT(P) --------\n");
  // Read outputs from mult
    for (i=0; i<4; i++) {
            neorv32_uart0_printf("[%i] Reading RX data... ", i);
            slink_rc = neorv32_slink_rx_status();
                if (slink_rc == SLINK_FIFO_EMPTY) {
                    neorv32_uart0_printf("FAILED! RX FIFO empty!\n");
                    break;
                }
                else {  
                    neorv32_uart0_printf("0x%x\n", neorv32_slink_get());
                }
    }
  // End
  neorv32_uart0_printf("\nProgram execution completed.\n");
  #endif

  return 0;
}
\end{minted}
\caption{SLINK main.c}
\label{ap-cod:11}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{c}
#include <neorv32.h>
#include <string.h>

#define BAUD_RATE 19200

// This defines is used to bypass the intermediate print functions between wishbone functions (for latency and throughput measurements)
// Comment these defines to perform a normal execution
// Uncomment latency to perform latency measurements
// Uncomment throughput to perform throughput measurements
//#define latency
//#define throughput

int main() {
    
  // Capture all exceptions and give debug info via UART0
  neorv32_rte_setup();

  // Setup UART at default baud rate, no interrupts
  neorv32_uart0_setup(BAUD_RATE, 0);

  // Check if UART0 unit is implemented at all
  if (neorv32_uart0_available() == 0) {
    return -1; // abort if not implemented
  }

  // check if the CPU base counters are implemented
  if ((neorv32_cpu_csr_read(CSR_MXISA) & (1 << CSR_MXISA_ZICNTR)) == 0) {
    neorv32_uart0_printf("ERROR! Base counters ('Zicntr' ISA extensions) not implemented!\n");
    return -1;
  }

  // Declaration of variables 
  // address 0x90000000
  static uint32_t add = 0x90000000;
  //0000000000000001 x 0000000000000001
  static uint32_t fir = 0x00010001;
  //0000000000000010 x 0000000000000010
  static uint32_t sec = 0x00020002;
  //0000000000000100 x 0000000000000100
  static uint32_t thi = 0x00040004;
  //0000000000001000 x 0000000000001000
  static uint32_t fou = 0x00080008;

  #ifdef latency
  // Intro
  neorv32_uart0_printf("\n W-lat \n\n");
  // Write 4 inputs to mult and read the outputs from mult one by one
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cpu_store_unsigned_word(add, fir);
    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cpu_store_unsigned_word(add, sec);
    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cpu_store_unsigned_word(add, thi);
    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cpu_store_unsigned_word(add, fou);
    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE); 

  // End
  neorv32_uart0_printf("\nEND-lat\n");
  #elif defined throughput
  // Intro
  neorv32_uart0_printf("\n W-thr \n\n");
  // Write 4 inputs to mult

    neorv32_cpu_store_unsigned_word(add, fir);

    neorv32_cpu_store_unsigned_word(add, sec);

    neorv32_cpu_store_unsigned_word(add, thi);

    neorv32_cpu_store_unsigned_word(add, fou);

  // Read outputs from mult

    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);

    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE);

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cpu_load_unsigned_word(add);
    neorv32_cpu_csr_read(CSR_MCYCLE);

  // End
  neorv32_uart0_printf("\nEND-thr\n");
  #else
  int i;
  // Intro
  neorv32_uart0_printf("\n<<< MULT(P) via external memory interface (EMEM) demo program >>>\n\n");
  neorv32_uart0_printf("-------- Write data to MULT(P) --------\n");
  // Write 4 inputs to mult
    for (i=0; i<4 ; i++) {
    if(i==0){
            neorv32_cpu_store_unsigned_word(add, fir);
            neorv32_uart0_printf("\n[%i] Sending 0x%x to address 0x%x \n",i,fir,add);
           } 
    if(i==1){
            neorv32_cpu_store_unsigned_word(add, sec);
            neorv32_uart0_printf("\n[%i] Sending 0x%x to address 0x%x \n",i,sec,add);
           }   
    if(i==2){
            neorv32_cpu_store_unsigned_word(add, thi);
            neorv32_uart0_printf("\n[%i] Sending 0x%x to address 0x%x \n",i,thi,add);
           }   
    if(i==3){
            neorv32_cpu_store_unsigned_word(add, fou);
            neorv32_uart0_printf("\n[%i] Sending 0x%x to address 0x%x \n",i,fou,add);
           }   
  } 
  neorv32_uart0_printf("\n-------- Read data from MULT(P) --------\n");
  // Read outputs from mult
    for (i=0; i<4; i++) {
        neorv32_uart0_printf("\n[%i] The read data is 0x%x \n",i,neorv32_cpu_load_unsigned_word(add));
      }
  // End
  neorv32_uart0_printf("\nProgram execution completed.\n");
  #endif

  return 0;
}
\end{minted}
\caption{XBUS main.c}
\label{ap-cod:12}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{c}
#include <neorv32.h>
#include <string.h>

#define BAUD_RATE 19200

// This defines is used to bypass the intermediate print functions between cfu functions (for latency measurements)
// Comment these defines to perform a normal execution
// Uncomment lat_mult to perform latency measurements with mult_wfifos
// Uncomment lat_multpw to perform latency measurements with multp_wfifos
// Uncomment lat_multp to perform latency measurements with multp
//#define lat_mult
//#define lat_multpw
//#define lat_multp

int main() {
    
  // Capture all exceptions and give debug info via UART0
  neorv32_rte_setup();

  // Setup UART at default baud rate, no interrupts
  neorv32_uart0_setup(BAUD_RATE, 0);

  // Check if UART0 unit is implemented at all
  if (neorv32_uart0_available() == 0) {
    return -1; // abort if not implemented
  }

  // check if the CFU is implemented at all (the CFU is wrapped in the core's "Zxcfu" ISA extension)
  if (neorv32_cpu_cfu_available() == 0) {
    neorv32_uart0_printf("ERROR! CFU ('Zxcfu' ISA extensions) not implemented!\n");
    return 1;
  }

  // check if the CPU base counters are implemented
  if ((neorv32_cpu_csr_read(CSR_MXISA) & (1 << CSR_MXISA_ZICNTR)) == 0) {
    neorv32_uart0_printf("ERROR! Base counters ('Zicntr' ISA extensions) not implemented!\n");
    return -1;
  }

  // Declaration of variables 
  //0000000000000001 x 0000000000000001
  static uint32_t fir = 0x00010001;
  //0000000000000010 x 0000000000000010
  static uint32_t sec = 0x00020002;
  //0000000000000100 x 0000000000000100
  static uint32_t thi = 0x00040004;
  //0000000000001000 x 0000000000001000
  static uint32_t fou = 0x00080008;

  #ifdef lat_mult
  // Intro
  neorv32_uart0_printf("\n CFU-mw \n\n");
 // Perform 4 multiplication through custom instruction (funct3=000)
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b000, fir, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b000, sec, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b000, thi, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b000, fou, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 
  // End
  neorv32_uart0_printf("\nEND-mw\n");
  #elif defined lat_multpw
  // Intro
  neorv32_uart0_printf("\n CFU-mpw \n\n");
 // Perform 4 multiplication through custom instruction (funct3=001)
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b001, fir, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b001, sec, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b001, thi, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b001, fou, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 
  // End
  neorv32_uart0_printf("\nEND-mpw\n");
  #elif defined lat_multp
  // Intro
  neorv32_uart0_printf("\n CFU-mp \n\n");
 // Perform 4 multiplication through custom instruction (funct3=010)
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b010, fir, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b010, sec, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b010, thi, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b010, fou, 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 
  // End
  neorv32_uart0_printf("\nEND-mp\n");
  #else
  int i;
  // Intro
  neorv32_uart0_printf("\n<<< MULT(P) via CFU demo program >>>\n\n");
  neorv32_uart0_printf("\n--- CFU R3-Type: Multiplier Instruction ---\n");
  neorv32_uart0_printf("\n rs1= 0xIN1-IN2, rs2= DC, rd = IN1 x IN2 \n\n");
  // Write 4 inputs to mult and read the outputs from mult one by one in mult_wfifos
    neorv32_uart0_printf("\n Mult_wfifos: \n\n");
    for (i=0; i<4 ; i++) {
    if(i==0){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b000, [rs1]=0x%x, [rs2]=0x%x ) = ", i, fir, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b000, fir, 0)); 
           } 
    if(i==1){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b000, [rs1]=0x%x, [rs2]=0x%x ) = ", i, sec, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b000, sec, 0));  
           }   
    if(i==2){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b000, [rs1]=0x%x, [rs2]=0x%x ) = ", i, thi, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b000, thi, 0));  
           }   
    if(i==3){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b000, [rs1]=0x%x, [rs2]=0x%x ) = ", i, fou, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b000, fou, 0)); 
           }   
    } 
  // Write 4 inputs to mult and read the outputs from mult one by one in multp_wfifos
    neorv32_uart0_printf("\n Multp_wfifos: \n\n");
    for (i=0; i<4 ; i++) {
    if(i==0){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b001, [rs1]=0x%x, [rs2]=0x%x ) = ", i, fir, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b001, fir, 0)); 
           } 
    if(i==1){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b001, [rs1]=0x%x, [rs2]=0x%x ) = ", i, sec, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b001, sec, 0));  
           }   
    if(i==2){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b001, [rs1]=0x%x, [rs2]=0x%x ) = ", i, thi, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b001, thi, 0));  
           }   
    if(i==3){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b001, [rs1]=0x%x, [rs2]=0x%x ) = ", i, fou, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b001, fou, 0)); 
           }   
    } 
  // Write 4 inputs to mult and read the outputs from mult one by one in multp
    neorv32_uart0_printf("\n Multp: \n\n");
    for (i=0; i<4 ; i++) {
    if(i==0){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b010, [rs1]=0x%x, [rs2]=0x%x ) = ", i, fir, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b010, fir, 0)); 
           } 
    if(i==1){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b010, [rs1]=0x%x, [rs2]=0x%x ) = ", i, sec, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b010, sec, 0));  
           }   
    if(i==2){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b010, [rs1]=0x%x, [rs2]=0x%x ) = ", i, thi, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b010, thi, 0));  
           }   
    if(i==3){
            neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b010, [rs1]=0x%x, [rs2]=0x%x ) = ", i, fou, 0);
            neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b010, fou, 0)); 
           }   
    } 
  // End
  neorv32_uart0_printf("\nCFU demo program completed.\n");
  #endif

  return 0;
}
\end{minted}
\caption{CFU main.c}
\label{ap-cod:13}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{c}
#include <neorv32.h>

#define BAUD_RATE 19200

// This defines is used to bypass the intermediate print functions between cfs functions (for latency and throughput measurements)
// Comment these defines to perform a normal execution
// Uncomment latency to perform latency measurements
// Uncomment throughput to perform throughput measurements
//#define latency
//#define throughput

int main() {

  // Capture all exceptions and give debug info via UART0
  neorv32_rte_setup();

  // Setup UART at default baud rate, no interrupts
  neorv32_uart0_setup(BAUD_RATE, 0);

  // Check if UART0 unit is implemented at all
  if (neorv32_uart0_available() == 0) {
    return -1; // abort if not implemented
  }

  // check if CFS is implemented at all
  if (neorv32_cfs_available() == 0) {
    neorv32_uart0_printf("Error! No CFS synthesized!\n");
    return 1;
  }

  // check if the CPU base counters are implemented
  if ((neorv32_cpu_csr_read(CSR_MXISA) & (1 << CSR_MXISA_ZICNTR)) == 0) {
    neorv32_uart0_printf("ERROR! Base counters ('Zicntr' ISA extensions) not implemented!\n");
    return -1;
  }

  // Declaration of variables 
  //0000000000000001 x 0000000000000001
  static uint32_t fir = 0x00010001;
  //0000000000000010 x 0000000000000010
  static uint32_t sec = 0x00020002;
  //0000000000000100 x 0000000000000100
  static uint32_t thi = 0x00040004;
  //0000000000001000 x 0000000000001000
  static uint32_t fou = 0x00080008;


  #ifdef latency
  // Intro
  neorv32_uart0_printf("\n CFS-lat \n\n");
  // Write 4 inputs to mult and read the outputs from mult one by one
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = fir; // Write fir to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write fir to mult
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read fir from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = sec; // Write sec to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write sec to mult
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read sec from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = thi; // Write thi to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write thi to mult
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read thi from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = fou; // Write fou to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write fou to mult
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read fou from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

  // End
  neorv32_uart0_printf("\nEND-lat\n");
  #elif defined throughput
  // Intro
  neorv32_uart0_printf("\n CFS-thr \n\n");
  // Write 4 inputs to mult
    NEORV32_CFS->REG[0] = fir; // Write fir to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write fir to mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals

    NEORV32_CFS->REG[0] = sec; // Write sec to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write sec to mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals

    NEORV32_CFS->REG[0] = thi; // Write thi to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write thi to mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals

    NEORV32_CFS->REG[0] = fou; // Write fou to CFS memory-mapped register 0
    NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write fou to mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals

  // Read outputs from mult
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read data from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);

    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read data from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read data from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read data from mult
    NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

  // End
  neorv32_uart0_printf("\nEND-thr\n");
  #else
  // Intro
  int i;
  neorv32_uart0_printf("\n<<< MULT(P) via CFS demo program >>>\n\n");
  neorv32_uart0_printf("CFS memory-mapped registers:\n"
                       " * NEORV32_CFS->REG[0] (r/w): input/output data register.\n"
                       " * NEORV32_CFS->REG[1] (w): control signals register. 01 Write to MULT(P) - 10 Read from MULT(P) - 00 Clean control signals\n\n");
  neorv32_uart0_printf("-------- Write data to MULT(P) --------\n");
  // Write 4 inputs to mult and read the outputs from mult one by one
    for (i=0; i<4 ; i++) {
    if(i==0){
            NEORV32_CFS->REG[0] = fir; // Write fir to CFS memory-mapped register 0
            NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write fir to mult
            NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read fir from mult
            NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, fir, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           } 
    if(i==1){
            NEORV32_CFS->REG[0] = sec; // Write sec to CFS memory-mapped register 0
            NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write sec to mult
            NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read sec from mult
            NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, sec, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           }   
    if(i==2){
            NEORV32_CFS->REG[0] = thi; // Write thi to CFS memory-mapped register 0
            NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write thi to mult
            NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read thi from mult
            NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, thi, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           }   
    if(i==3){
            NEORV32_CFS->REG[0] = fou; // Write fou to CFS memory-mapped register 0
            NEORV32_CFS->REG[1] = 1; // Write 01 to CFS memory-mapped register 1; Write fou to mult
            NEORV32_CFS->REG[1] = 2; // write 10 to CFS memory-mapped register 1; Read fou from mult
            NEORV32_CFS->REG[1] = 0; // Write 00 to CFS memory-mapped register 1; Clean the control signals
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, fou, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           }   
    } 
  // End
  neorv32_uart0_printf("\nCFS demo program completed.\n");
  #endif

  return 0;
}
\end{minted}
\caption{CFS \textit{buffered} main.c}
\label{ap-cod:14}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{c}
#include <neorv32.h>

#define BAUD_RATE 19200

// This defines is used to bypass the intermediate print functions between CFS functions (for latency measurements)
// Comment these defines to perform a normal execution
// Uncomment latency to perform latency measurements
//#define latency

int main() {

  // Capture all exceptions and give debug info via UART0
  neorv32_rte_setup();

  // Setup UART at default baud rate, no interrupts
  neorv32_uart0_setup(BAUD_RATE, 0);

  // Check if UART0 unit is implemented at all
  if (neorv32_uart0_available() == 0) {
    return -1; // abort if not implemented
  }

  // check if CFS is implemented at all
  if (neorv32_cfs_available() == 0) {
    neorv32_uart0_printf("Error! No CFS synthesized!\n");
    return 1;
  }

  // check if the CPU base counters are implemented
  if ((neorv32_cpu_csr_read(CSR_MXISA) & (1 << CSR_MXISA_ZICNTR)) == 0) {
    neorv32_uart0_printf("ERROR! Base counters ('Zicntr' ISA extensions) not implemented!\n");
    return -1;
  }

  // Declaration of variables 
  //0000000000000001 x 0000000000000001
  static uint32_t fir = 0x00010001;
  //0000000000000010 x 0000000000000010
  static uint32_t sec = 0x00020002;
  //0000000000000100 x 0000000000000100
  static uint32_t thi = 0x00040004;
  //0000000000001000 x 0000000000001000
  static uint32_t fou = 0x00080008;


  #ifdef latency
  // Intro
  neorv32_uart0_printf("\n CFS-lat \n\n");
  // Write 4 inputs to mult and read the outputs from mult one by one
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = fir; // Write fir to CFS memory-mapped register 0
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = sec; // Write sec to CFS memory-mapped register 0
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = thi; // Write thi to CFS memory-mapped register 0
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    NEORV32_CFS->REG[0] = fou; // Write fou to CFS memory-mapped register 0
    NEORV32_CFS->REG[0]; // Read mult result from CFS memory-mapped register 0  
    neorv32_cpu_csr_read(CSR_MCYCLE); 

  // End
  neorv32_uart0_printf("\nEND-lat\n");
  #else
  // Intro
  int i;
  neorv32_uart0_printf("\n<<< MULT(P) via CFS demo program >>>\n\n");
  neorv32_uart0_printf("CFS memory-mapped registers:\n"
                       " * NEORV32_CFS->REG[0] (r/w): input/output data register.\n\n");
  neorv32_uart0_printf("-------- Write data to MULT(P) --------\n");
  // Write 4 inputs to mult and read the outputs from mult one by one
    for (i=0; i<4 ; i++) {
    if(i==0){
            NEORV32_CFS->REG[0] = fir; // Write fir to CFS memory-mapped register 0
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, fir, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           } 
    if(i==1){
            NEORV32_CFS->REG[0] = sec; // Write sec to CFS memory-mapped register 0
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, sec, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           }   
    if(i==2){
            NEORV32_CFS->REG[0] = thi; // Write thi to CFS memory-mapped register 0
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, thi, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           }   
    if(i==3){
            NEORV32_CFS->REG[0] = fou; // Write fou to CFS memory-mapped register 0
            neorv32_uart0_printf("%i: IN = 0x%x, OUT = 0x%x\n", i, fou, NEORV32_CFS->REG[0]);  // Read mult result from CFS memory-mapped register 0  
           }   
    } 
  // End
  neorv32_uart0_printf("\nCFS demo program completed.\n");
  #endif

  return 0;
}
\end{minted}
\caption{CFS \textit{unbuffered} main.c}
\label{ap-cod:15}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- ================================================================================ --
-- NEORV32 CPU - Co-Processor: Custom (RISC-V Instructions) Functions Unit (CFU)    --
-- -------------------------------------------------------------------------------- --
-- For custom/user-defined RISC-V instructions (R3-type, R4-type and R5-type        --
-- formats). See the  CPU's documentation for more information. Also take a look at --
-- the "software-counterpart" this default CFU hardware in 'sw/example/demo_cfu'.   --
-- -------------------------------------------------------------------------------- --
-- The NEORV32 RISC-V Processor - https://github.com/stnolting/neorv32              --
-- Copyright (c) NEORV32 contributors.                                              --
-- Copyright (c) 2020 - 2024 Stephan Nolting. All rights reserved.                  --
-- Licensed under the BSD-3-Clause license, see LICENSE for details.                --
-- SPDX-License-Identifier: BSD-3-Clause                                            --
-- ================================================================================ --

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library neorv32;
use neorv32.neorv32_package.all;

entity neorv32_cpu_cp_cfu is
  port (
    -- global control --
    clk_i       : in  std_ulogic; -- global clock, rising edge
    rstn_i      : in  std_ulogic; -- global reset, low-active, async
    ctrl_i      : in  ctrl_bus_t; -- main control bus
    start_i     : in  std_ulogic; -- trigger operation
    -- CSR interface --
    csr_we_i    : in  std_ulogic; -- write enable
    csr_addr_i  : in  std_ulogic_vector(1 downto 0); -- address
    csr_wdata_i : in  std_ulogic_vector(XLEN-1 downto 0); -- write data
    csr_rdata_o : out std_ulogic_vector(XLEN-1 downto 0) := (others => '0'); -- read data
    -- data input --
    rs1_i       : in  std_ulogic_vector(XLEN-1 downto 0); -- rf source 1
    rs2_i       : in  std_ulogic_vector(XLEN-1 downto 0); -- rf source 2
    rs3_i       : in  std_ulogic_vector(XLEN-1 downto 0); -- rf source 3
    rs4_i       : in  std_ulogic_vector(XLEN-1 downto 0); -- rf source 4
    -- result and status --
    res_o       : out std_ulogic_vector(XLEN-1 downto 0) := (others => '0'); -- operation result
    valid_o     : out std_ulogic := '0' -- data output valid
  );
end neorv32_cpu_cp_cfu;

architecture neorv32_cpu_cp_cfu_rtl of neorv32_cpu_cp_cfu is

  -- CFU Control ---------------------------------------------
  -- ------------------------------------------------------------
  type control_t is record
    busy   : std_ulogic; -- CFU is busy
    done   : std_ulogic; -- set to '1' when processing is done
    result : std_ulogic_vector(XLEN-1 downto 0); -- CFU processing result (for write-back to register file)
    rtype  : std_ulogic_vector(1 downto 0); -- instruction type, see constants below
    funct3 : std_ulogic_vector(2 downto 0); -- "funct3" bit-field from custom instruction word
    funct7 : std_ulogic_vector(6 downto 0); -- "funct7" bit-field from custom instruction word
  end record;
  signal control : control_t;

  -- instruction format types --
  constant r3type_c  : std_ulogic_vector(1 downto 0) := "00"; -- R3-type instructions (custom-0 opcode)
  constant r4type_c  : std_ulogic_vector(1 downto 0) := "01"; -- R4-type instructions (custom-1 opcode)
  constant r5typeA_c : std_ulogic_vector(1 downto 0) := "10"; -- R5-type instruction A (custom-2 opcode)
  constant r5typeB_c : std_ulogic_vector(1 downto 0) := "11"; -- R5-type instruction B (custom-3 opcode)

  -- User-Defined Logic --------------------------------------
  -- ------------------------------------------------------------

  constant N_bits : natural := 32; -- 32 bits (16 bits plus 16 bits)
  constant Log2_elements : natural := 2; -- Log2 is 2 ergo FIFO has 4 elements

  signal reset : std_logic;

  type mult_wfifos_t is record
    sreg : std_ulogic_vector(5 downto 0); -- 6 cycles latency = 6 bits in arbitration shift register + 1 cycle for output = 7 cycles in total
    done : std_logic;
    --
    input : std_logic_vector(31 downto 0);
    output : std_logic_vector(31 downto 0);
    output_u  : std_ulogic_vector(31 downto 0);
    wr : std_logic;
    rd : std_logic;
  end record;
  signal mw : mult_wfifos_t;

  type multp_wfifos_t is record
    sreg : std_ulogic_vector(3 downto 0); -- 4 cycles latency = 4 bits in arbitration shift register + 1 cycle for output = 5 cycles in total
    done : std_logic;
    --
    input : std_logic_vector(31 downto 0);
    output : std_logic_vector(31 downto 0);
    output_u  : std_ulogic_vector(31 downto 0);
    wr : std_logic;
    rd : std_logic;
  end record;
  signal mpw : multp_wfifos_t;

  type multp_t is record
    sreg : std_logic; -- 1 cycle latency = 1 bit in arbitration shift register + 1 cycle for output = 2 cycles in total
    done : std_logic;
    --
    input : std_logic_vector(31 downto 0);
    output : std_logic_vector(31 downto 0);
    output_u  : std_ulogic_vector(31 downto 0);
  end record;
  signal mp : multp_t;

begin

  -- ********************************************************************
  -- This controller is required to handle the CFU-CPU interface.
  -- ********************************************************************

  -- CFU Controller -------------------------------------------------------------------------
  -- ---------------------------------------------------------------------
  -- The <control> record acts as proxy logic that ensures correct communication with the
  -- CPU pipeline. However, this control instance adds one additional cycle of latency.
  -- Advanced users can remove this default control instance to obtain maximum throughput.
  cfu_control: process(rstn_i, clk_i)
  begin
    if (rstn_i = '0') then
      res_o        <= (others => '0');
      control.busy <= '0';
    elsif rising_edge(clk_i) then
      res_o <= (others => '0'); -- default; all CPU co-processor outputs are logically OR-ed
      if (control.busy = '0') then -- CFU is idle
        control.busy <= start_i; -- trigger new CFU operation
      else -- CFU operation in progress
        res_o <= control.result; -- output result only if CFU is processing; has to be all-zero otherwise
        if (control.done = '1') or (ctrl_i.cpu_trap = '1') then -- operation done or abort if trap (exception)
          control.busy <= '0';
        end if;
      end if;
    end if;
  end process cfu_control;

  -- CPU feedback --
  valid_o <= control.busy and control.done; -- set one cycle before result data

  -- pack user-defined instruction type/function bits --
  control.rtype  <= ctrl_i.ir_opcode(6 downto 5);
  control.funct3 <= ctrl_i.ir_funct3;
  control.funct7 <= ctrl_i.ir_funct12(11 downto 5);

  reset <= not(rstn_i);

  -- Mult_wfifos instantation

  mult_wfifos_0 : entity work.mult_wfifos
                generic map (N_bits => N_bits,
                             Log2_elements => Log2_elements)
                port map (clk_wr => clk_i,
                          clk_mult => clk_i,
                          clk_rd => clk_i,
                          rst => reset,
                          din => mw.input,
                          dout => mw.output,
                          wr => mw.wr,
                          rd => mw.rd,
                          full => open,
                          empty => open);

  -- Multp_wfifos instantation

  multp_wfifos_0 : entity work.multp_wfifos
                 generic map (g_data_width => N_bits,
                              g_fifo_depth => Log2_elements)
                 port map (clk_in => clk_i,
                           clk_mult => clk_i,
                           clk_out => clk_i,
                           rst => reset,
                           din => mpw.input,
                           dout => mpw.output,
                           write => mpw.wr,
                           read => mpw.rd,
                           full => open,
                           empty => open);

  -- Multp instantation

  multp_0 : entity work.multp_op
                 generic map (g_data_width => N_bits)
                 port map (din => mp.input,
                           dout => mp.output);

  -- Inputs
  mw.input <= To_StdLogicVector(rs1_i)  when control.funct3 = "000" and start_i = '1' else
              (others => '0');
  mpw.input <= To_StdLogicVector(rs1_i) when control.funct3 = "001" and start_i = '1' else
              (others => '0');
  mp.input <= To_StdLogicVector(rs1_i)  when mp.done = '1' else
              (others => '0');

  -- Outputs
  mw.output_u <= To_StdULogicVector(mw.output);
  mpw.output_u <= To_StdULogicVector(mpw.output);
  mp.output_u <= To_StdULogicVector(mp.output);

    -- Iteration control
    iteration_control: process(rstn_i, clk_i)
    begin
      if (rstn_i = '0') then
        mw.sreg <= (others => '0');
        mpw.sreg <= (others => '0');
        mp.sreg <= '0';
      elsif rising_edge(clk_i) then
        -- operation trigger --
        if (control.busy = '0') and -- CFU is idle (ready for next operation)
           (start_i = '1') and -- CFU is actually triggered by a custom instruction word
           (control.rtype = r3type_c) and -- this is a R3-type instruction
           (control.funct3 = "000") then -- trigger only for 000 funct3 value
             mw.sreg(0) <= '1';
        elsif (control.busy = '0') and -- CFU is idle (ready for next operation)
              (start_i = '1') and -- CFU is actually triggered by a custom instruction word
              (control.rtype = r3type_c) and -- this is a R3-type instruction
              (control.funct3 = "001") then -- trigger only for 001 funct3 value
             mpw.sreg(0) <= '1';
        elsif (control.busy = '0') and -- CFU is idle (ready for next operation)
              (start_i = '1') and -- CFU is actually triggered by a custom instruction word
              (control.rtype = r3type_c) and -- this is a R3-type instruction
              (control.funct3 = "010") then -- trigger only for 010 funct3 value
             mp.sreg <= '1';
        else
             mw.sreg(0) <= '0';
             mpw.sreg(0) <= '0';
             mp.sreg <= '0';
        end if;
        -- simple shift register for tracking operation --
          mw.sreg(mw.sreg'left downto 1) <= mw.sreg(mw.sreg'left-1 downto 0); -- shift left
          mpw.sreg(mpw.sreg'left downto 1) <= mpw.sreg(mpw.sreg'left-1 downto 0); -- shift left
        end if;
      end process iteration_control;

      -- Processing has reached last stage (= done) when mult_wfifos sreg's MSB is set --
      mw.done <= mw.sreg(mw.sreg'left);

      -- Processing has reached last stage (= done) when multp_wfifos sreg's MSB is set --
      mpw.done <= mpw.sreg(mpw.sreg'left);

      -- Processing has reached last stage (= done) when multp sreg is equal to 1 --
      mp.done <= mp.sreg;

      -- Write signal for mult_wfifos when the operation starts
      mw.wr <= start_i when control.funct3 = "000" else
               '0';
      -- Write signal for multp_wfifos when the operation starts
      mpw.wr <= start_i when control.funct3 = "001" else
               '0';
      -- Read signal for mult_wfifos in the fifth iteration
      mw.rd <= mw.sreg(4);
      -- Read signal for multp_wfifos in the third iteration
      mpw.rd <= mpw.sreg(2);

-- Output select --------------------------------------------------------------------------
  -- -----------------------------------------------------------------------
    out_select: process(control, rs1_i, rs2_i, mw, mpw, mp)
    begin
      case control.rtype is
        when r3type_c => -- R3-type instructions
          case control.funct3 is
            when "000" => -- funct3 = "000": mult_wfifos
              control.result <= mw.output_u;
              control.done   <= mw.done; -- 6 cycles to perform multiplication
            when "001" => -- funct3 = "001": multp_wfifos
              control.result <= mpw.output_u;
              control.done   <= mpw.done; -- 4 cycles to perform multiplication
            when "010" => -- funct3 = "010": multp
              control.result <= mp.output_u;
              control.done   <= mp.done; -- 1 cycle to perform multiplication
            when others => -- not implemented
              control.result <= (others => '0');
              control.done   <= '0'; -- this will cause an illegal instruction exception after timeout
          end case;
        when others => -- undefined
        -- ----------------------------------------------------------------------
          control.result <= (others => '0');
          control.done   <= '0';
      end case;
    end process out_select;

end neorv32_cpu_cp_cfu_rtl;
\end{minted}
\caption{Archivo neorv32\_cpu\_cp\_cfu.vhd modificado para integrar los multiplicadores.}
\label{ap-cod:16}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- ================================================================================ --
-- NEORV32 SoC - Custom Functions Subsystem (CFS)                                   --
-- -------------------------------------------------------------------------------- --
-- Intended for tightly-coupled, application-specific custom co-processors. This    --
-- module provides up to 64x 32-bit memory-mapped interface registers, one CPU      --
-- interrupt request signal and custom IO conduits for processor-external or chip-  --
-- external interface.                                                              --
-- -------------------------------------------------------------------------------- --
-- The NEORV32 RISC-V Processor - https://github.com/stnolting/neorv32              --
-- Copyright (c) NEORV32 contributors.                                              --
-- Copyright (c) 2020 - 2024 Stephan Nolting. All rights reserved.                  --
-- Licensed under the BSD-3-Clause license, see LICENSE for details.                --
-- SPDX-License-Identifier: BSD-3-Clause                                            --
-- ================================================================================ --

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library neorv32;
use neorv32.neorv32_package.all;

entity neorv32_cfs is
  generic (
    CFS_CONFIG   : std_ulogic_vector(31 downto 0); -- custom CFS configuration generic
    CFS_IN_SIZE  : natural; -- size of CFS input conduit in bits
    CFS_OUT_SIZE : natural  -- size of CFS output conduit in bits
  );
  port (
    clk_i       : in  std_ulogic; -- global clock line
    rstn_i      : in  std_ulogic; -- global reset line, low-active, use as async
    bus_req_i   : in  bus_req_t; -- bus request
    bus_rsp_o   : out bus_rsp_t := rsp_terminate_c; -- bus response
    clkgen_en_o : out std_ulogic := '0'; -- enable clock generator
    clkgen_i    : in  std_ulogic_vector(7 downto 0); -- "clock" inputs
    irq_o       : out std_ulogic := '0'; -- interrupt request
    cfs_in_i    : in  std_ulogic_vector(CFS_IN_SIZE-1 downto 0); -- custom inputs
    cfs_out_o   : out std_ulogic_vector(CFS_OUT_SIZE-1 downto 0) := (others => '0') -- custom outputs
  );
end neorv32_cfs;

architecture neorv32_cfs_rtl of neorv32_cfs is

  -- MULT(P) interface registers --
  signal cfs_mult_data : std_ulogic_vector(31 downto 0);
  signal cfs_mult_control : std_ulogic_vector(31 downto 0);
  signal cfs_mult_res : std_ulogic_vector(31 downto 0);

begin

  clkgen_en_o <= '0'; -- not used for this minimal example

  irq_o <= '0'; -- not used for this minimal example

  bus_access: process(rstn_i, clk_i)
  begin
    if (rstn_i = '0') then
      cfs_mult_data <= (others => '0');
      cfs_mult_control <= (others => '0');
      --
      bus_rsp_o.ack  <= '0';
      bus_rsp_o.err  <= '0';
      bus_rsp_o.data <= (others => '0');
    elsif rising_edge(clk_i) then -- synchronous interface for read and write accesses
      -- transfer/access acknowledge --
      bus_rsp_o.ack <= bus_req_i.stb;

      -- tie to zero if not explicitly used --
      bus_rsp_o.err <= '0';

      -- defaults --
      bus_rsp_o.data <= (others => '0'); -- the output HAS TO BE ZERO if there is no actual (read) access

      -- bus access --
      if (bus_req_i.stb = '1') then -- valid access cycle, STB is high for one cycle

        -- write access --
        if (bus_req_i.rw = '1') then
          if (bus_req_i.addr(7 downto 2) = "000000") then -- address size is fixed!
            cfs_mult_data <= bus_req_i.data; -- write to CFS memory-mapped register 0; MULT(P) inputs
          end if;
          if (bus_req_i.addr(7 downto 2) = "000001") then
            cfs_mult_control <= bus_req_i.data; -- write to CFS memory-mapped register 1; MULT(P) control
          end if;

        -- read access --
        else
          case bus_req_i.addr(7 downto 2) is -- address size is fixed!
            when "000000" => bus_rsp_o.data <= cfs_mult_res; -- read from CFS memory-mapped register 0; MULT(P) outputs
            when others   => bus_rsp_o.data <= (others => '0');
          end case;
        end if;

      end if;
    end if;
  end process bus_access;

-- cfs_mult_control(1) => Read from MULT(P)
-- cfs_mult_control(0) => Write to MULT(P)

-- Concatenate/make output; cfs_out_o => 34 bits (2 bit for control MSB + 32 bit for data)
 cfs_out_o <= cfs_mult_control(1) & cfs_mult_control(0) & cfs_mult_data; 

-- cfs_in_i => 32 bits; MULT(P) output (16 bits x 16 bits)

 cfs_mult_res <= cfs_in_i;

end neorv32_cfs_rtl;
\end{minted}
\caption{Archivo neorv32\_cfs.vhd modificado para gestionar los multiplicadores \textit{buffered}.}
\label{ap-cod:17}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- ================================================================================ --
-- NEORV32 SoC - Custom Functions Subsystem (CFS)                                   --
-- -------------------------------------------------------------------------------- --
-- Intended for tightly-coupled, application-specific custom co-processors. This    --
-- module provides up to 64x 32-bit memory-mapped interface registers, one CPU      --
-- interrupt request signal and custom IO conduits for processor-external or chip-  --
-- external interface.                                                              --
-- -------------------------------------------------------------------------------- --
-- The NEORV32 RISC-V Processor - https://github.com/stnolting/neorv32              --
-- Copyright (c) NEORV32 contributors.                                              --
-- Copyright (c) 2020 - 2024 Stephan Nolting. All rights reserved.                  --
-- Licensed under the BSD-3-Clause license, see LICENSE for details.                --
-- SPDX-License-Identifier: BSD-3-Clause                                            --
-- ================================================================================ --

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library neorv32;
use neorv32.neorv32_package.all;

entity neorv32_cfs is
  generic (
    CFS_CONFIG   : std_ulogic_vector(31 downto 0); -- custom CFS configuration generic
    CFS_IN_SIZE  : natural; -- size of CFS input conduit in bits
    CFS_OUT_SIZE : natural  -- size of CFS output conduit in bits
  );
  port (
    clk_i       : in  std_ulogic; -- global clock line
    rstn_i      : in  std_ulogic; -- global reset line, low-active, use as async
    bus_req_i   : in  bus_req_t; -- bus request
    bus_rsp_o   : out bus_rsp_t := rsp_terminate_c; -- bus response
    clkgen_en_o : out std_ulogic := '0'; -- enable clock generator
    clkgen_i    : in  std_ulogic_vector(7 downto 0); -- "clock" inputs
    irq_o       : out std_ulogic := '0'; -- interrupt request
    cfs_in_i    : in  std_ulogic_vector(CFS_IN_SIZE-1 downto 0); -- custom inputs
    cfs_out_o   : out std_ulogic_vector(CFS_OUT_SIZE-1 downto 0) := (others => '0') -- custom outputs
  );
end neorv32_cfs;

architecture neorv32_cfs_rtl of neorv32_cfs is

  -- MULT(P) interface registers --
  signal cfs_mult_data : std_ulogic_vector(31 downto 0);
  signal cfs_mult_res : std_ulogic_vector(31 downto 0);

begin

  clkgen_en_o <= '0'; -- not used for this minimal example

  irq_o <= '0'; -- not used for this minimal example

  bus_access: process(rstn_i, clk_i)
  begin
    if (rstn_i = '0') then
      cfs_mult_data <= (others => '0');
      --
      bus_rsp_o.ack  <= '0';
      bus_rsp_o.err  <= '0';
      bus_rsp_o.data <= (others => '0');
    elsif rising_edge(clk_i) then -- synchronous interface for read and write accesses
      -- transfer/access acknowledge --
      bus_rsp_o.ack <= bus_req_i.stb;

      -- tie to zero if not explicitly used --
      bus_rsp_o.err <= '0';

      -- defaults --
      bus_rsp_o.data <= (others => '0'); -- the output HAS TO BE ZERO if there is no actual (read) access

      -- bus access --
      if (bus_req_i.stb = '1') then -- valid access cycle, STB is high for one cycle

        -- write access --
        if (bus_req_i.rw = '1') then
          if (bus_req_i.addr(7 downto 2) = "000000") then -- address size is fixed!
            cfs_mult_data <= bus_req_i.data; -- write to CFS memory-mapped register 0; MULT(P) inputs
          end if;

        -- read access --
        else
          case bus_req_i.addr(7 downto 2) is -- address size is fixed!
            when "000000" => bus_rsp_o.data <= cfs_mult_res; -- read from CFS memory-mapped register 0; MULT(P) outputs
            when others   => bus_rsp_o.data <= (others => '0');
          end case;
        end if;

      end if;
    end if;
  end process bus_access;

-- Make output
 cfs_out_o <= cfs_mult_data; 

-- cfs_in_i => 32 bits; MULT(P) output (16 bits x 16 bits)

 cfs_mult_res <= cfs_in_i;

end neorv32_cfs_rtl;
\end{minted}
\caption{neorv32\_cfs.vhd}
\label{ap-cod:18}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
library ieee;
context ieee.ieee_std_context;

library neorv32;
use neorv32.neorv32_package.all;

library vunit_lib;
context vunit_lib.vunit_context;

entity tb_complex_mults_cfu is
  generic (
    runner_cfg : string
  );
end entity;

architecture tb of tb_complex_mults_cfu is

signal clk : std_logic := '0';
signal rst : std_logic := '0';
signal rstn : std_logic := '0';
signal gpio_a : std_ulogic_vector(7 downto 0);
signal uart0_txd : std_logic;

constant baud0_rate_c            : natural := 19200;
constant CLOCK_FREQUENCY         : natural := 100000000;

constant uart0_baud_val_c : real := real(CLOCK_FREQUENCY) / real(baud0_rate_c);

constant clk_period : time := 10 ns;

signal ctrl_bus : ctrl_bus_t;

signal funct3 : std_ulogic_vector(2 downto 0);
signal rs1 : std_ulogic_vector(31 downto 0);
signal res_CFU : std_ulogic_vector(31 downto 0);
signal start_CFU : std_logic;

signal csr_we : std_logic;
signal csr_valid : std_logic;
signal csr_addr : std_ulogic_vector(11 downto 0);
signal csr_wdata : std_ulogic_vector(31 downto 0);
signal csr_rdata_o : std_ulogic_vector(31 downto 0);


-- Logging

constant logger : logger_t := get_logger("tb_complex_mults_cfu");
constant file_handler : log_handler_t := new_log_handler(
  output_path(runner_cfg) & "log.csv",
  format => csv,
  use_color => false
);

-- Test items (make sure that they are equal to the items defined in the software)

constant test_items : natural := 4;
type test_t is array (0 to test_items-1, 0 to 2) of integer;
constant test_data : test_t := (
  (1, 1, 1),
  (2, 2, 4),
  (4, 4, 16),
  (8, 8, 64)
);

signal start, done: boolean := false;

begin

neorv32_mults_cfu_0 : entity work.neorv32_mults_cfu
                                                generic map(
                                                            CLOCK_FREQUENCY => CLOCK_FREQUENCY,
                                                            MEM_INT_IMEM_SIZE => 16384,
                                                            MEM_INT_DMEM_SIZE => 8192
                                                           )
                                                port map (
                                                            clk_i => clk,
                                                            rstn_i => rstn,
                                                            gpio_o => gpio_a,
                                                            uart0_txd_o => uart0_txd,
                                                            uart0_rxd_i => uart0_txd
                                                          );
  -- UART Simulation Receiver ---------------------------------------------------------------
  -- -------------------------------------------------------------------------------------------
  uart0_checker: entity work.uart_rx_simple
  generic map (
    name => "uart0",
    uart_baud_val_c => uart0_baud_val_c
  )
  port map (
    clk => clk,
    uart_txd => uart0_txd
  );

  clk <= not clk after clk_period/2;
  rstn <= not rst;

  -- Capture control bus through external names

  ctrl_bus <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst .neorv32_cpu_alu_inst.neorv32_cpu_cp_cfu_inst_true.neorv32_cpu_cp_cfu_inst.ctrl_i : ctrl_bus_t >>;

  -- To display in vcd file 
  funct3 <= ctrl_bus.ir_funct3;

  rs1 <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst .neorv32_cpu_alu_inst.neorv32_cpu_cp_cfu_inst_true.neorv32_cpu_cp_cfu_inst.rs1_i : std_ulogic_vector(31 downto 0) >>;
  res_CFU <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst .neorv32_cpu_alu_inst.neorv32_cpu_cp_cfu_inst_true.neorv32_cpu_cp_cfu_inst.res_o : std_ulogic_vector(31 downto 0) >>;
  start_CFU <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst .neorv32_cpu_alu_inst.neorv32_cpu_cp_cfu_inst_true.neorv32_cpu_cp_cfu_inst.start_i : std_logic >>;

  -- Capture CSR signals through external names
  csr_we <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst .neorv32_cpu_control_inst.xcsr_we_o : std_logic >>;
  csr_addr <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst .neorv32_cpu_control_inst.xcsr_addr_o : std_ulogic_vector(11 downto 0) >>;
  csr_wdata <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst .neorv32_cpu_control_inst.xcsr_wdata_o : std_ulogic_vector(31 downto 0) >>;
  csr_rdata_o <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst .neorv32_cpu_control_inst.csr_rdata_o : std_ulogic_vector(31 downto 0) >>;
  csr_valid <= << signal .tb_complex_mults_cfu.neorv32_mults_cfu_0.neorv32_top_inst.core_complex.neorv32_cpu_inst .neorv32_cpu_control_inst.csr_reg_valid : std_logic >>;

  main: process
  begin
    test_runner_setup(runner, runner_cfg);
    while test_suite loop
      if run("test") then
        set_log_handlers(logger, (display_handler, file_handler));
        show_all(logger, file_handler);
        show_all(logger, display_handler);

        rst <= '1';
        wait for 15*clk_period;
        rst <= '0';
        info(logger, "Init test");
        wait until rising_edge(clk);
        start <= true;
        wait until rising_edge(clk);
        start <= false;
        wait until (done and rising_edge(clk));
        info(logger, "Test done");
      end if;
    end loop;
    test_runner_cleanup(runner);
    wait;
  end process;

  mycycle_capture: process
  begin
    done <= false;
    wait until start and rising_edge(clk);
    for x in 0 to test_items-1 loop
      wait until rising_edge(clk) and csr_we = '0' and csr_valid = '1' and csr_addr = x"B00" and csr_rdata_o /= x"00000000"; -- CSR MYCYCLE ADDR IS 0xB00
      info(logger, "Data " & to_string(x+1) & "/" & to_string(test_items) & " latency is " & to_string(to_integer(unsigned(csr_rdata_o))-1) & " cycles"); -- Remove one cycle, see gh:stnolting/neorv32/issues/897
      wait until rising_edge(clk);
    end loop;
    
    wait until rising_edge(clk);
    done <= true;
    wait;
  end process;

end architecture;
\end{minted}
\caption{tb\_complex\_mults\_cfu.vhd}
\label{ap-cod:19}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- Authors:
--   Unai Martinez-Corral & Unai Sainz-Estebanez
--     <unai.martinezcorral@ehu.eus>
--     <usainz003@ikasle.ehu.eus>
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- SPDX-License-Identifier: Apache-2.0

library ieee;
context ieee.ieee_std_context;

library vunit_lib;
context vunit_lib.vunit_context;
context vunit_lib.vc_context;

entity mult_wfifos_axis_vcs is
  generic (
    m_axis : axi_stream_master_t;
    s_axis : axi_stream_slave_t;
    N_bits : natural := 32;
    Log2_elements : natural := 4;
    test_items : natural := 4;
    logger : logger_t
  );
  port (
    clk, rstn: in std_logic
  );
end entity;

architecture arch of mult_wfifos_axis_vcs is

  signal m_valid, m_ready, s_valid, s_ready : std_logic;
  signal m_data, s_data : std_logic_vector(data_length(m_axis)-1 downto 0);

begin

  vunit_axism: entity vunit_lib.axi_stream_master
  generic map (
    master => m_axis
  )
  port map (
    aclk   => clk,
    tvalid => m_valid,
    tready => m_ready,
    tdata  => m_data,
    tlast  => open
  );

  vunit_axiss: entity vunit_lib.axi_stream_slave
  generic map (
    slave => s_axis
  )
  port map (
    aclk   => clk,
    tvalid => s_valid,
    tready => s_ready,
    tdata  => s_data,
    tlast  => open
  );

--

  uut: entity work.mult_wfifos_axis
  generic map (
    N_bits => N_bits,
    Log2_elements => Log2_elements
  )
  port map (
    clk_mult => clk,
    s_axis_clk   => clk,
    s_axis_rstn  => rstn,
    s_axis_rdy   => m_ready,
    s_axis_data  => m_data,
    s_axis_valid => m_valid,
    m_axis_clk   => clk,
    m_axis_rstn  => rstn,
    m_axis_valid => s_valid,
    m_axis_data  => s_data,
    m_axis_rdy   => s_ready
  );

-- To extract time information through the INFO function, for latency measurements

  send_trigger: process
  begin

    for x in 0 to test_items-1 loop
      wait until rising_edge(clk) and m_valid = '1' and m_ready = '1';
      info(logger, "Data (" & to_string(m_data(31 downto 16)) & "x" & to_string(m_data(15 downto 0))  & ") " & to_string(x+1) & "/" & to_string(test_items) & " sent!");
    end loop;
  end process;

  received_trigger: process
  begin

    for x in 0 to test_items-1 loop
      wait until rising_edge(clk) and s_valid = '1' and s_ready = '1';
      info(logger, "Data (" & to_string(s_data) & ") " & to_string(x+1) & "/" & to_string(test_items) & " received!");
    end loop;
  end process;

end architecture;
\end{minted}
\caption{mult\_wfifos\_axis\_vcs.vhd}
\label{ap-cod:20}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- Authors:
--   Unai Martinez-Corral & Unai Sainz-Estebanez
--     <unai.martinezcorral@ehu.eus>
--     <usainz003@ikasle.ehu.eus>
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- SPDX-License-Identifier: Apache-2.0

library ieee;
context ieee.ieee_std_context;

library vunit_lib;
context vunit_lib.vunit_context;
context vunit_lib.vc_context;

entity tb_mult_wfifos_axis_latency is
  generic (
    runner_cfg : string
  );
end entity;

architecture tb of tb_mult_wfifos_axis_latency is

  -- Simulation constants

  constant clk_period : time    := 10 ns;
  constant data_width : natural := 32;

  -- AXI4Stream Verification Components

  constant master_axi_stream : axi_stream_master_t := new_axi_stream_master(
    data_length => data_width,
    stall_config => new_stall_config(0.0, 1, 10)
  );
  constant slave_axi_stream  : axi_stream_slave_t  := new_axi_stream_slave(
    data_length => data_width,
    stall_config => new_stall_config(0.0, 1, 10)
  );

  -- Logging

  constant logger : logger_t := get_logger("tb_mult_wfifos_axis_latency");
  constant file_handler : log_handler_t := new_log_handler(
    output_path(runner_cfg) & "log.csv",
    format => csv,
    use_color => false
  );

  -- tb signals and variables

  signal clk, rst, rstn : std_logic := '0';
  signal start, done : boolean := false;

  constant test_items : natural := 4;
  type test_t is array (0 to test_items-1, 0 to 2) of integer;
  constant test_data : test_t := (
    (1, 1, 1),
    (2, 2, 4),
    (4, 4, 16),
    (8, 8, 64)
  );

begin

  clk <= not clk after clk_period/2;
  rstn <= not rst;

  main: process
  begin
    test_runner_setup(runner, runner_cfg);
    while test_suite loop
      if run("test") then
        set_log_handlers(logger, (display_handler, file_handler));
        show_all(logger, file_handler);
        show_all(logger, display_handler);

        rst <= '1';
        wait for 15*clk_period;
        rst <= '0';
        info(logger, "Init test");
        wait until rising_edge(clk);
        start <= true;
        wait until rising_edge(clk);
        start <= false;
        wait until (done and rising_edge(clk));
        info(logger, "Test done");
      end if;
    end loop;
    test_runner_cleanup(runner);
    wait;
  end process;

  stimuli: process
    variable word : std_logic_vector(data_width-1 downto 0);
    variable o : std_logic_vector(31 downto 0);
    variable last : std_logic:='0';
  begin
    done <= false;
    wait until start and rising_edge(clk);

    for x in 0 to test_items-1 loop
      word(data_width-1 downto data_width/2) := std_logic_vector(to_signed(test_data(x, 0), data_width/2));
      word(data_width/2-1 downto 0) := std_logic_vector(to_signed(test_data(x, 1), data_width/2));
      push_axi_stream(net, master_axi_stream, word);
      pop_axi_stream(net, slave_axi_stream, tdata => o, tlast => last);
      check_equal(signed(o),to_signed(test_data(x,2), data_width),"This is a failure!");
    end loop;

    wait until rising_edge(clk);
    done <= true;
    wait;
  end process;

  uut_vc: entity work.mult_wfifos_axis_vcs
  generic map (
    m_axis => master_axi_stream,
    s_axis => slave_axi_stream,
    N_bits => data_width,
    Log2_elements => 3,
    test_items => test_items,
    logger => logger
  )
  port map (
    clk  => clk,
    rstn => rstn
  );

end architecture;
\end{minted}
\caption{tb\_mult\_wfifos\_axis\_latency.vhd}
\label{ap-cod:21}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{python}
#!/usr/bin/env python3

from _csv import Error, __version__, writer, reader, register_dialect
from pathlib import Path
import re
import types
import csv
import os

# This program reads the simulation output csv and displays the latency of the operations
# Run this script after running run.py

# The path of the folder where the csv files are located is defined
ROOT = Path(__file__).parent
csv_path = ROOT / "vunit_out" / "outcsv"

# To choose the design an environment variable is defined. 'mult' value by default.
DESIGN = os.environ.get("DESIGN","mult")

# Specify the csv output file according to envvar
if DESIGN == "mult":
    csv_file = csv_path / "tb_mult_wfifos_axis_latency.csv"
elif DESIGN == "multp-wfifos":
    csv_file = csv_path / "tb_multp_wfifos_axis_latency.csv"
elif DESIGN == "multp":
    csv_file = csv_path / "tb_multp_axis_latency.csv"
else:
    print("The valid envvar values are: mult, multp-wfifos and multp")
    exit()

# The lists are defined
time=[]
time_num=[]
line=[]
sent=[]
received=[]

# Function to open csv and read from it
with open(csv_file, newline='') as csvfile:
    # Reading function; ',' delimeter is selected
    csv_reader = csv.reader(csvfile, delimiter=',', quotechar='|')
    # Take the first value of the fourth column (Name of vhdl file where the csv comes from)    
    name=next(csv_reader)[3]
    # Reset the csv file handle
    csvfile.seek(0)
    # Loop through the csv file 
    for row in csv_reader:
        # Filling the time/line lists with the second column (time of the operations) and the fifth column (line where the operation comes from)
        time.append(row[1])
        line.append(row[4])

# Loop for remove " fs"
for i in range(0, len(time)):
    a=time[i]
    a=a.replace(" fs","")
    time_num.append(a)

# Define the matrix with the time and lines information
matrix = [time_num,line]

# Filling the sent and the received lists
# Note that to have the line information the vu.enable_location_preprocessing() function must be in the program run.py
for k in range(0,len(line)):
    if int(matrix[1][k]) == 100: # If the time information comes from line 99 is sent information
        sent.append(matrix[0][k]) # Save the sent time information
    elif int(matrix[1][k]) == 109: # If the time information comes from line 108 is received information
        received.append(matrix[0][k]) # Save the received time information

if len(sent) != len(received):
    print("Error: the sent length is not equal to the received length")
    exit()

# Print the name of vhdl file where the csv comes from
print("---- For",name,"file ----")

# Loop for display the latency of the operations
for z in range(0,len(sent)):
    # Casting from string to integer
    k = int(received[z]) - int(sent[z])
    if z == 0:
        print("The latency is:",k,"fs -",int(k/10000000),"cycles")
    # Send/received data latency
    print("Data",z+1,"of",len(sent),"sent/received latency is:",k,"fs -",int(k/10000000),"cycles")
\end{minted}
\caption{latency.py}
\label{ap-cod:22}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{bash}
#!/usr/bin/env bash

set -ex

cd $(dirname "$0")

if [[ -z "${Board}" ]]; then
  Arty='35t'
elif [[ $Board == '35t' ]]; then
  Arty='35t'
elif [[ $Board == '100t' ]]; then
  Arty='100t'
else
  echo "Error Board must be 35t or 100t"
  exit
fi
echo "Selected board is" $Arty

apt update -qq

apt install -y git

cd ../..

git clone --recursive https://github.com/stnolting/neorv32-setups

mv rtl/mult/CFU/neorv32_application_image.vhd neorv32-setups/neorv32/rtl/core
mv rtl/mult/CFU/neorv32_cpu_cp_cfu.vhd neorv32-setups/neorv32/rtl/core

mkdir -p build

echo "Analyze NEORV32 CPU + MULT(P) via CFU"

ghdl -i --std=08 --workdir=build --work=neorv32  ./neorv32-setups/neorv32/rtl/core/*.vhd
ghdl -i --std=08 --workdir=build --work=neorv32  ./neorv32-setups/neorv32/rtl/core/mem/neorv32_dmem.default.vhd
ghdl -i --std=08 --workdir=build --work=neorv32  ./neorv32-setups/neorv32/rtl/core/mem/neorv32_imem.default.vhd
ghdl -i --std=08 --workdir=build --work=neorv32 ./rtl/mult/*.vhd
ghdl -i --std=08 --workdir=build --work=neorv32 ./rtl/multp/*.vhd
ghdl -i --std=08 --workdir=build --work=neorv32 ./rtl/mult/CFU/neorv32_mults_cfu.vhd
ghdl -m --std=08 --workdir=build --work=neorv32 neorv32_mults_cfu

echo "Synthesis with yosys and ghdl as module"

yosys -m ghdl -p 'ghdl --std=08 --workdir=build --work=neorv32 neorv32_mults_cfu; synth_xilinx -nodsp -nolutram -flatten -abc9 -arch xc7 -top neorv32_mults_cfu; write_json neorv32_mults_cfu.json' 

if [[ $Arty == '35t' ]]; then
  echo "Place and route"
  nextpnr-xilinx --chipdb /usr/local/share/nextpnr/xilinx-chipdb/xc7a35t.bin --xdc impl/nextpnr/arty.xdc --json neorv32_mults_cfu.json --write neorv32_mults_cfu_routed.json --fasm neorv32_mults_cfu.fasm
  echo "Generate bitstream"
  ../../prjxray/utils/fasm2frames.py --part xc7a35tcsg324-1 --db-root /usr/local/share/nextpnr/prjxray-db/artix7 neorv32_mults_cfu.fasm > neorv32_mults_cfu.frames
  ../../prjxray/build/tools/xc7frames2bit --part_file /usr/local/share/nextpnr/prjxray-db/artix7/xc7a35tcsg324-1/part.yaml --part_name xc7a35tcsg324-1 --frm_file neorv32_mults_cfu.frames --output_file neorv32_mults_cfu_35t.bit
elif [[ $Arty == '100t' ]]; then
  echo "Place and route"
  nextpnr-xilinx --chipdb /usr/local/share/nextpnr/xilinx-chipdb/xc7a100t.bin --xdc impl/nextpnr/arty.xdc --json neorv32_mults_cfu.json --write neorv32_mults_cfu_routed.json --fasm neorv32_mults_cfu.fasm
  echo "Generate bitstream"
  ../../prjxray/utils/fasm2frames.py --part xc7a100tcsg324-1 --db-root /usr/local/share/nextpnr/prjxray-db/artix7 neorv32_mults_cfu.fasm > neorv32_mults_cfu.frames
  ../../prjxray/build/tools/xc7frames2bit --part_file /usr/local/share/nextpnr/prjxray-db/artix7/xc7a100tcsg324-1/part.yaml --part_name xc7a100tcsg324-1 --frm_file neorv32_mults_cfu.frames --output_file neorv32_mults_cfu_100t.bit
fi

echo "Implementation completed"
\end{minted}
\caption{impl\_mults\_cfu.sh}
\label{ap-cod:23}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
----------------------------------------------------------------------------------
-- Company: UPV/EHU
-- Engineer: Koldo Basterretxea & Unai Sainz
-- 
-- Create Date: 25.06.2024
-- Design Name: 
-- Module Name: top_CRIsig_vunit - RTL
-- Project Name: 
-- Target Devices: 
-- Tool Versions: 
-- Description: 
-- 
-- Dependencies: Fixed point package -- 
-- Additional Comments: parameters are WL (word-length) and prec (arithmetic precision)
-- Programmable slope and saturatio and applied interpolation depth (q) in runtime
-- Latency: q+2 clock cycles (this version registers inut and outputs). q+1 if the output or input register is avoided
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
-- 
----------------------------------------------------------------------------------
       
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.fixed_pkg.all;
use ieee.fixed_float_types.all;
    
        
entity top_CRIsig_vunit is
 generic (WL: natural := 16; --input&output WL
          prec : natural := 8); --internal precision (frcational bits)
    Port ( clk : in STD_LOGIC;
           rst : in STD_LOGIC;
           ce : in STD_LOGIC;
           q : in STD_LOGIC_VECTOR (2 downto 0);
           slope : in STD_LOGIC_VECTOR (2 downto 0);
           satu : in STD_LOGIC_VECTOR (2 downto 0);
           in_x : in STD_LOGIC_VECTOR (WL-1 downto 0);
           out_y : out STD_LOGIC_VECTOR (WL-1 downto 0);
           done : out STD_LOGIC);
end top_CRIsig_vunit;
        
architecture RTL of top_CRIsig_vunit is
--constrained std_logic_vector to avoid indexing errors in type conversion of u_fixed to std_logic_vector
subtype result_type is std_logic_vector (WL-1 downto 0);
--	Load optimum delta values in a ROM (16 bits (u,2,14))
type rom_type is array (1 to 6) of ufixed(1 downto -14);
constant rom_sig : rom_type := (to_ufixed(1.2364,1,-14),to_ufixed(1.1244,1,-14),to_ufixed(1.0636,1,-14) ,to_ufixed(1.0552,1,-14),to_ufixed(1.0512,1,-14),to_ufixed(1.0512,1,-14));
-- constant rom_tan : rom_type := (to_ufixed(2.4728,1,-14),to_ufixed(2.2488,1,-14),to_ufixed(2.1268,1,-14) ,to_ufixed(2.1108,1,-14),to_ufixed(2.1028,1,-14),to_ufixed(2.1020,1,-14));

--Since we compute not only squashing functions, in this version we consider WL-prec integer bits
--for inputs and outputs
SIGNAL counter : unsigned(2 downto 0);
SIGNAL rl,ssat, sslope : integer range -3 to 7;
SIGNAL sel_reg, sel: STD_LOGIC;
SIGNAL rom_out : ufixed (4 downto -prec);--min integer bits depend on allowed sat params
SIGNAL delta, delta_reg : ufixed (4 downto -prec);--min integer bits depend on allowed sat params
SIGNAL input_abs, reg_input, reg_out, output : std_logic_vector(WL-1 downto 0);
SIGNAL input_pos, y21, y22: ufixed (WL-prec-1 downto -prec);
SIGNAL y2, h, hx, hxp, hxp_reg, hxp_a, hxp_s, g, gx, min_mux: ufixed (6 downto -prec); -- max sat value is 2^7
SIGNAL outpre, resta : ufixed (WL-prec-1 downto -prec);
SIGNAL outpre2, resta2 : sfixed (WL-prec-1 downto -prec);
SIGNAL out_neg, out_CRI : sfixed (WL-prec-1 downto -prec);
SIGNAL zeroes: std_logic_vector (WL-prec-3 downto 0):= (others => '0');
 
begin
        rl <= to_integer(unsigned(q));
        sslope <= to_integer(signed(slope));
        ssat <= to_integer(signed(satu));
    
        -----------------------------------------------------------
        ---------------------COUNTER(q) and status-----------------	
        recursion: PROCESS(clk)
        BEGIN
            IF(rising_edge(clk)) THEN
                IF(rst='1') OR (ce='1')THEN --start counting when input is registered
                    counter <= "000";
                    sel<='0';
                    done<='0';
                ELSIF(counter = rl) THEN
                        counter <= "000" ;
                        sel<='0';
                        done<='1';
                ELSE
                    counter<=counter+1;
                    sel<='1';
                    done<='0';
                END IF;
            END IF;
        END PROCESS;
        -----------------------------------------------------------
        -----------------------DELTA-------------------------------	
     
        rom_out <= resize(rom_sig(3),rom_out) sll ssat;  --adjust interpolation depth according to saturation value
        
        WITH sel SELECT
             delta <= resize(rom_out,delta) WHEN '0', --First value of delta
                                  delta_reg WHEN '1', 
                              (others=>'0') when others;
        
        delta_gen: PROCESS(clk)
            BEGIN
                IF(rising_edge(clk)) THEN
                    IF (rst='1') THEN
                        delta_reg <= (others=>'0');
                    ELSE
                      delta_reg <= shift_right(delta,2); --divide by four (delta/4)
                    END IF;
                END IF;
            END PROCESS;
        -----------------------------------------------------------
        -- This version registers input (with ce signal)
        reg_in: PROCESS(clk)
            BEGIN
                IF(rising_edge(clk)) THEN
                    IF (rst='1') THEN
                       reg_input <= (others=>'0');
                    ELSIF (ce='1') THEN
                       reg_input <= in_x;
                    END IF;
                END IF;
            END PROCESS;
        -----------------------------------------------------------	
        -- Convert inputs to positive values u(16,8)

        input_abs <= std_logic_vector(signed(not(reg_input)) + 1);  --2's complement
        WITH reg_input(WL-1) SELECT
             input_pos <= to_ufixed(reg_input,input_pos) WHEN '0', 
                          to_ufixed(input_abs,input_pos) WHEN '1',
                                           (others=>'0') when others;
                         
        ---------------------------------------------------------------------------
        -------------------------------CRI-----------------------------------------
        -- Initila affine functions
        -- y2 = (satu/2)*(1+((slope/2)*x));
        -- y2 <= resize(resize(resize(input_pos sll sslope-1,input_pos)+1,input_pos) sll ssat-1,y2);
        y21 <= resize(input_pos sll sslope-1,input_pos);
        y22 <= resize(y21+1,input_pos);
        y2 <= resize(y22 sll ssat-1,y2);
        -- compute g(x) at each iteration
        WITH sel SELECT
                  g <= y2 WHEN '0',        --g(x)=y2(x) at first iteration
                  min_mux WHEN '1',  --g(x)=Min[g(x),h(x)] remainding iterations
            (others=>'0') when others;
        
        reg_gx: PROCESS(clk) --register g(x)
            BEGIN
                IF(rising_edge(clk)) THEN
                    IF (rst='1') THEN
                        gx <= (others=>'0');
                    ELSE
                        gx <= g;
                    END IF;
                END IF;
            END PROCESS;
        
        -- control signal 'sel' must be delayed one cycle
        h_select: PROCESS(clk)
            BEGIN
                IF(rising_edge(clk)) THEN
                    IF (rst='1') THEN
                        sel_reg <= '1';
                    ELSE
                        sel_reg <= sel;
                    END IF;
                END IF;
            END PROCESS;	
        
        -- Compute h(x) at each iteration

        h <= resize(to_ufixed(1,h) sll ssat,h);

        WITH sel_reg SELECT 
                      hx <= h WHEN '0', --h(x)=y3(x)=sat initially
                      hxp_reg WHEN '1',
                (others=>'0') when others;
        
        --h(x)=1/2(g(x)+h(x)-delta)
        hxp_a <= resize(gx+hx, hxp_a);
        hxp_s <= resize(hxp_a - delta_reg, hxp_s);
        --hxp <= '0' & hxp_s(1 DOWNTO -prec+1);
        hxp <= hxp_s sra 1;
        
        reg_hxp: PROCESS(clk)
            BEGIN
                IF(rising_edge(clk)) THEN
                    IF (rst='1') THEN
                        hxp_reg <= (others=>'0');
                    ELSE
                        hxp_reg <= hxp;
                    END IF;
                END IF;
            END PROCESS;

        -- Min operation
        min_mux <= gx when gx <= hx else
                   hx;
        -----------------------------------------------------------
        ---------------------OUTPUT--------------------------------	
    
        outpre <= resize(min_mux,outpre);
        resta <= resize(h, resta);
        
        -- Transform to signed for substraction
        resta2  <= to_sfixed(resta (WL-prec-2 downto -prec));
        outpre2 <= to_sfixed(outpre(WL-prec-2 downto -prec)); 

        out_neg <= resize(resta2-outpre2,out_neg);
                                
        WITH reg_input(WL-1) SELECT -- negative inputs
	       out_CRI <= resize(to_sfixed(outpre),out_CRI) WHEN '0',
               --out_CRI <= resize(add_sign(outpre),out_CRI) WHEN '0',
                                                out_neg WHEN '1',
                                          (others=>'0') when others;	
                                      
        -- output casting(WL-prec integer bits and prec frac bits) 
        output <= result_type(out_CRI);
        -------------------------------------------------------------
--        -- This version registers output (with sel signal)
--        reg_output: PROCESS(clk)
--            BEGIN
--                IF(rising_edge(clk)) THEN
--                    IF (rst='1') THEN
--                       reg_out <= (others=>'0');
--                    ELSIF (sel='0') THEN
--                   reg_out <= output;
--                END IF;
--            END IF;
--        END PROCESS;
        
        out_y <= output;
end RTL;
\end{minted}
\caption{top\_CRIsig\_vunit.vhd}
\label{ap-cod:24}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{vhdl}
-- ================================================================================ --
-- NEORV32 CPU - Co-Processor: Custom (RISC-V Instructions) Functions Unit (CFU)    --
-- -------------------------------------------------------------------------------- --
-- For custom/user-defined RISC-V instructions See the  CPU's documentation for     --
-- more information. Also take a look at the "software-counterpart" this default    --
-- CFU hardware in 'sw/example/demo_cfu'.                                           --
-- -------------------------------------------------------------------------------- --
-- The NEORV32 RISC-V Processor - https://github.com/stnolting/neorv32              --
-- Copyright (c) NEORV32 contributors.                                              --
-- Copyright (c) 2020 - 2024 Stephan Nolting. All rights reserved.                  --
-- Licensed under the BSD-3-Clause license, see LICENSE for details.                --
-- SPDX-License-Identifier: BSD-3-Clause                                            --
-- ================================================================================ --

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity neorv32_cpu_cp_cfu is
  port (
    -- global control --
    clk_i       : in  std_ulogic; -- global clock, rising edge
    rstn_i      : in  std_ulogic; -- global reset, low-active, async
    -- operation control --
    start_i     : in std_ulogic; -- operation trigger/strobe
    active_i    : in std_ulogic; -- operation in progress, CPU is waiting for CFU
    -- CSR interface --
    csr_we_i    : in  std_ulogic; -- write enable
    csr_addr_i  : in  std_ulogic_vector(1 downto 0); -- address
    csr_wdata_i : in  std_ulogic_vector(31 downto 0); -- write data
    csr_rdata_o : out std_ulogic_vector(31 downto 0) := (others => '0'); -- read data
    -- operands --
    rtype_i     : in std_ulogic; -- instruction type (R3-type or R4-type)
    funct3_i    : in std_ulogic_vector(2 downto 0); -- "funct3" bit-field from custom instruction word
    funct7_i    : in std_ulogic_vector(6 downto 0); -- "funct7" bit-field from custom instruction word
    rs1_i       : in  std_ulogic_vector(31 downto 0); -- rf source 1
    rs2_i       : in  std_ulogic_vector(31 downto 0); -- rf source 2
    rs3_i       : in  std_ulogic_vector(31 downto 0); -- rf source 3
    -- result and status --
    result_o    : out std_ulogic_vector(31 downto 0) := (others => '0'); -- operation result
    valid_o     : out std_ulogic := '0' -- result valid, operation done; set one cycle before result_o is valid
  );
end neorv32_cpu_cp_cfu;

architecture neorv32_cpu_cp_cfu_rtl of neorv32_cpu_cp_cfu is

  -- CFU instruction type formats --
  constant r3type_c : std_ulogic := '0'; -- R3-type CFU instructions (custom-0 opcode)
  constant r4type_c : std_ulogic := '1'; -- R4-type CFU instructions (custom-1 opcode)

  constant WL   : natural := 16;    -- Input/Output Word Length 
  constant prec : natural := 8;     -- Internal precision (frcational bits)

  signal reset : std_logic;

  -- processing logic --
  type sig_t is record
    ce        : std_logic;
    done      : std_logic;
    q         : std_logic_vector(2 downto 0); 
    slope     : std_logic_vector(2 downto 0); 
    satu      : std_logic_vector(2 downto 0); 
    input     : std_logic_vector(WL-1 downto 0);
    output    : std_logic_vector(WL-1 downto 0);
    output_u  : std_ulogic_vector(31 downto 0);
    fill      : std_ulogic_vector(32-WL-1 downto 0);
  end record;
  -- Define the signal and initialize it
  signal sig : sig_t := (ce       => '0',
                         done     => '0',
                         q        => "011", -- q=3
                         slope    => "111", -- slope=0.5 (shift -1)
                         satu     => "001", -- sat=2 (shift 1)
                         input    => (others => '0'),
                         output   => (others => '0'),
                         output_u => (others => '0'),
                         fill     => (others => '0'));

begin

  reset <= not(rstn_i) or not(active_i);

  -- top_CRIsig_vunit instantation

  top_CRIsig_vunit_0 : entity work.top_CRIsig_vunit
                       generic map (WL   => WL,
                                    prec => prec)
                       port map (clk     => clk_i,
                                 rst     => reset,
                                 ce      => sig.ce,
                                 q       => sig.q,
                                 slope   => sig.slope,
                                 satu    => sig.satu,
                                 in_x    => sig.input,
                                 out_y   => sig.output,
                                 done    => sig.done);

  -- Input
  sig.input <= To_StdLogicVector(rs1_i(WL-1 downto 0)) when funct3_i = "000" and rtype_i = r3type_c and start_i = '1' else
              (others => '0');

  -- Output
  out_reg: process(rstn_i,clk_i)
  begin
    if(rstn_i='0') then
      sig.output_u <= (others => '0');
    elsif rising_edge(clk_i) then
        if(sig.done = '1') then
          sig.output_u <= sig.fill & To_StdULogicVector(sig.output);     
        else
          sig.output_u <= (others => '0'); 
        end if;
    end if;
  end process out_reg;

  -- CE signal
  sig.ce <= '1' when funct3_i = "000" and rtype_i = r3type_c and (start_i = '1' or sig.done = '1') else
            '0';

  -- Function Result Select -----------------------------------------------------------------
  -- -----------------------------------------------------------------------
  result_select: process(rtype_i, funct3_i, sig)
  begin
    case rtype_i is -- check instruction type

      when r3type_c => -- R3-type instructions; function select via "funct3" and ""funct7
      -- ----------------------------------------------------------------------
        case funct3_i is -- Just check "funct3" here; "funct7" bit-field is ignored
          when "000" => 
            result_o <= sig.output_u; 
            valid_o  <= sig.done; 
          when others => -- all unspecified operations
            result_o <= (others => '0'); -- no logic implemented
            valid_o  <= '0'; -- this will cause an illegal instruction exception after timeout
        end case;
      when others => -- undefined
      -- ----------------------------------------------------------------------
        result_o <= (others => '0'); -- no logic implemented
        valid_o  <= '0'; -- this will cause an illegal instruction exception after timeout

    end case;
  end process result_select;

end neorv32_cpu_cp_cfu_rtl;
\end{minted}
\caption{SIGMOIDE(CRI) neorv32\_cpu\_cp\_cfu.vhd}
\label{ap-cod:25}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{python}
#!/usr/bin/env python3

import numpy as np
import matplotlib.pyplot as plt

# Definir la función original
def original_function(x):
    return 2 * (1 / (1 + np.exp(-0.5 * x)))

# Definir el rangos de x
x_range = np.linspace(-10, 10, 100)

# Calcular los valores de la función original en eso rango
y_range = original_function(x_range)

# Ajustar polinomios de grado 3, 5 y 7
poly_3 = np.polyfit(x_range, y_range, 3)
poly_5 = np.polyfit(x_range, y_range, 5)
poly_7 = np.polyfit(x_range, y_range, 7)

# Evaluar los polinomios ajustados en el rango respectivo
y_poly_3 = np.polyval(poly_3, x_range) 
y_poly_7 = np.polyval(poly_7, x_range)  
y_poly_5 = np.polyval(poly_5, x_range) 

# Imprimir los coeficientes de los polinomios de aproximación
print("Polinomio de aproximación de grado 3 para el rango [-10, 10]:")
print(f"{poly_3[3]:.11f} + {poly_3[2]:.11f}x + {poly_3[1]:.11f}x^2 + {poly_3[0]:.11f}x^3")
print("Polinomio de aproximación de grado 5 para el rango [-10, 10]:")
print(f"{poly_5[5]:.11f} + {poly_5[4]:.11f}x + {poly_5[3]:.11f}x^2 + {poly_5[2]:.11f}x^3 + {poly_5[1]:.11f}x^4 + {poly_5[0]:.11f}x^5")
print("Polinomio de aproximación de grado 7 para el rango [-10, 10]:")
print(f"{poly_7[7]:.11f} + {poly_7[6]:.11f}x + {poly_7[5]:.11f}x^2 + {poly_7[4]:.11f}x^3 + {poly_7[3]:.11f}x^4 + {poly_7[2]:.11f}x^5 + {poly_7[1]:.11f}x^6 + {poly_7[0]:.11f}x^7")

# Visualizar los resultados para los valores testeados

data=[-10,-7.5,-5,-2.5,0,2.5,5,7.5,10]

#for i in range(0,9):
#    print("Aproximación Grado 7;   f("+ str(data[i]) +"):", poly_7[7] + poly_7[6]*data[i] + poly_7[5]*data[i]**2 + poly_7[4]*data[i]**3 + poly_7[3]*data[i]**4 + poly_7[2]*data[i]**5 + poly_7[1]*data[i]**6 + poly_7[0]*data[i]**7)
#    print("Aproximación Grado 5;   f("+ str(data[i]) +"):", poly_5[5] + poly_5[4]*data[i] + poly_5[3]*data[i]**2 + poly_5[2]*data[i]**3 + poly_5[1]*data[i]**4 + poly_5[0]*data[i]**5)
#    print("Aproximación Grado 3;   f("+ str(data[i]) +"):", poly_3[3] + poly_3[2]*data[i] + poly_3[1]*data[i]**2 + poly_3[0]*data[i]**3)
#    print("Original coma flotante; f("+ str(data[i]) +"):", 2 * (1 / (1 + np.exp(-0.5 * data[i]))))

for i in range(0,9):
    print("Aproximación Grado 7;   f("+ str(data[i]) +"):", poly_7[7] + poly_7[6]*data[i] + poly_7[4]*data[i]**3 + poly_7[2]*data[i]**5 + poly_7[0]*data[i]**7)
    print("Aproximación Grado 5;   f("+ str(data[i]) +"):", poly_5[5] + poly_5[4]*data[i] + poly_5[2]*data[i]**3 + poly_5[0]*data[i]**5)
    print("Aproximación Grado 3;   f("+ str(data[i]) +"):", poly_3[3] + poly_3[2]*data[i] + poly_3[0]*data[i]**3)
    print("Original coma flotante; f("+ str(data[i]) +"):", 2 * (1 / (1 + np.exp(-0.5 * data[i]))))

# Crear una nueva figura y mejorar la interpretación de la gráfica
plt.figure(figsize=(10, 6))

# Gráficar
plt.plot(x_range, y_range, label="Original", color='blue')
plt.plot(x_range, y_poly_3, '-.', label="Aproximación de grado 3", color='purple')
plt.plot(x_range, y_poly_5, '--', label="Aproximación de grado 5", color='green')
plt.plot(x_range, y_poly_7, ':', label="Aproximación de grado 7", color='red')

# Mejorar la visualización
plt.legend(loc="best")
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Comparación entre la función original y las aproximaciones polinómicas de grado 3, 5 y 7.')

# Ajustar el rango de los ejes para que sea más claro
plt.xlim([-12, 12])  # Ajustar los límites del eje x
plt.ylim([0, 2.5])   # Ajustar los límites del eje y

# Añadir líneas de cuadrícula para facilitar la lectura
plt.grid(True)

# Mostrar la gráfica
plt.show()
\end{minted}
\caption{aprox\_poli.py}
\label{ap-cod:26}
\end{code}

\begin{code}
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,breaklines,linenos]{c}
#include <neorv32.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include "neorv32_zfinx_extension_intrinsics.h"

#define BAUD_RATE 19200

// This defines is used to bypass the intermediate print functions between cfu/FPU functions (for simulation)
// Comment this defines to perform a implementation
// Uncomment sim to perform a simulation
//#define sim

//    Floating point operations supported by the NEORV32 FPU
//    riscv_intrinsic_fadds()
//    riscv_intrinsic_fsubs()
//    riscv_intrinsic_fmuls()
//    The division operation is not supported, so the function is approximated with a polynomial.

float sig_aprox_7 (float x){
    // f(x)=1 + 0.24190955524x - 0.00369209483x^3 + 0.00003770457x^5 - 0.00000015213x^7; grade 7 approximation; range [-10 to 10]
    float a1 = 0.24190955524f;
    float a3 = -0.00369209483f;
    float a5 = 0.00003770457f;
    float a7 = -0.00000015213f;
    float inter1, inter2, inter3, inter4, pow1, pow2, pow3, pow4;
    float res, res1, res2, res3;
    
    inter1 = riscv_intrinsic_fmuls(a1,x);
    pow1 = riscv_intrinsic_fmuls(x,x);
    pow2 = riscv_intrinsic_fmuls(pow1,x);
    inter2 = riscv_intrinsic_fmuls(a3,pow2);
    pow3 = riscv_intrinsic_fmuls(pow2,pow1);
    inter3 = riscv_intrinsic_fmuls(a5,pow3);
    pow4 = riscv_intrinsic_fmuls(pow3,pow1);
    inter4 = riscv_intrinsic_fmuls(a7,pow4);
    res1 = riscv_intrinsic_fadds(1,inter1);
    res2 = riscv_intrinsic_fadds(res1,inter2);
    res3 = riscv_intrinsic_fadds(res2,inter3);
    res = riscv_intrinsic_fadds(res3,inter4);
    
    return res;
}

float sig_aprox_5 (float x){
    // f(x)=1 + 0.22878851178x - 0.00253272801x^3 + 0.00001266682x^5; grade 5 approximation; range [-10 to 10]
    float a1 = 0.22878851178f;
    float a3 = -0.00253272801f;
    float a5 = 0.00001266682f;
    float inter1, inter2, inter3, pow1, pow2, pow3;
    float res, res1, res2;
    
    inter1 = riscv_intrinsic_fmuls(a1,x);
    pow1 = riscv_intrinsic_fmuls(x,x);
    pow2 = riscv_intrinsic_fmuls(pow1,x);
    inter2 = riscv_intrinsic_fmuls(a3,pow2);
    pow3 = riscv_intrinsic_fmuls(pow2,pow1);
    inter3 = riscv_intrinsic_fmuls(a5,pow3);
    res1 = riscv_intrinsic_fadds(1,inter1);
    res2 = riscv_intrinsic_fadds(res1,inter2);
    res = riscv_intrinsic_fadds(res2,inter3);
    
    return res;
}

float sig_aprox_3 (float x){
    // f(x)=1 + 0.19744040439x - 0.00109773200x^3; grade 3 approximation; range [-10 to 10]
    float a1 = 0.19744040439f;
    float a3 = -0.00109773200f;
    float inter1, inter2, pow1, pow2;
    float res, res1;
    
    inter1 = riscv_intrinsic_fmuls(a1,x);
    pow1 = riscv_intrinsic_fmuls(x,x);
    pow2 = riscv_intrinsic_fmuls(pow1,x);
    inter2 = riscv_intrinsic_fmuls(a3,pow2);
    res1 = riscv_intrinsic_fadds(1,inter1);
    res = riscv_intrinsic_fadds(res1,inter2);
    
    return res;
}

int n_sign_decimal(float value) {
    int parte_entera = (int)value;
    float decimal = riscv_intrinsic_fsubs(value,(float)parte_entera);
    float eval_n = riscv_intrinsic_fmuls(decimal,10);
    float sign = riscv_intrinsic_flts(value,0);

    if(parte_entera == 0 && sign == 1)
        if((int)eval_n >= 1)
            return 1; //-0.x
        else
            return 2;//-0.0x
    else 
        if((int)eval_n >= 1)
            return 3; // != -0. ; x.y
        else
            return 4; // != -0. ; x.0y 
}

int main() {
    
  // Capture all exceptions and give debug info via UART0
  neorv32_rte_setup();

  // Setup UART at default baud rate, no interrupts
  neorv32_uart0_setup(BAUD_RATE, 0);

  // Check if UART0 unit is implemented at all
  if (neorv32_uart0_available() == 0) {
    return -1; // abort if not implemented
  }

  // check if Zfinx extension is implemented at all
  if ((neorv32_cpu_csr_read(CSR_MXISA) & (1<<CSR_MXISA_ZFINX)) == 0) {
    neorv32_uart0_puts("Error! <Zfinx> extension not synthesized!\n");
    return 1;
  }

  // check if the CFU is implemented at all (the CFU is wrapped in the core's "Zxcfu" ISA extension)
  if (neorv32_cpu_cfu_available() == 0) {
    neorv32_uart0_printf("ERROR! CFU ('Zxcfu' ISA extensions) not implemented!\n");
    return 1;
  }

  // check if the CPU base counters are implemented
  if ((neorv32_cpu_csr_read(CSR_MXISA) & (1 << CSR_MXISA_ZICNTR)) == 0) {
    neorv32_uart0_printf("ERROR! Base counters ('Zicntr' ISA extensions) not implemented!\n");
    return -1;
  }

  neorv32_cpu_csr_write(CSR_FCSR, 0); // clear exception flags and set "round to nearest"

  // Declaration of variables 
  //-10
  const uint32_t fir = 0x0000F600;
  //-7.5
  const uint32_t sec = 0x0000F880;
  //-5
  const uint32_t thi = 0x0000FB00;
  //-2.5
  const uint32_t fou = 0x0000FD80;
  //0
  const uint32_t fif = 0x00000000;
  //2.5
  const uint32_t six = 0x00000280;
  //5
  const uint32_t sev = 0x00000500;
  //7.5
  const uint32_t eig = 0x00000780;
  //10
  const uint32_t nin = 0x00000A00;
  //Input vector to hardware accelerator
  static uint32_t data_hw[9] = {fir,sec,thi,fou,fif,six,sev,eig,nin};
  //Input vector to software
  float data_sw[9] = {-10.0,-7.5,-5.0,-2.5,0.0,2.5,5.0,7.5,10.0};
  //Loop variable
  int i;

  #ifdef sim
  // Intro
  // Sigmoide-Comparation
  neorv32_uart0_printf("SIG-C");

  // Perform 9 operations through hardware accelerator (funct3=000)
  for (i=0; i<9; i++){
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    neorv32_cfu_r3_instr(0b1111111, 0b000, data_hw[i], 0); 
    neorv32_cpu_csr_read(CSR_MCYCLE); 
  }
  // Perform 9 operations through software with FPU (approximation degree 7)
  for (i=0; i<9; i++){
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    sig_aprox_7(data_sw[i]);
    neorv32_cpu_csr_read(CSR_MCYCLE); 
  }
  // Perform 9 operations through software with FPU (approximation degree 5)
  for (i=0; i<9; i++){
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    sig_aprox_5(data_sw[i]);
    neorv32_cpu_csr_read(CSR_MCYCLE); 
  }
  // Perform 9 operations through software with FPU (approximation degree 5)
  for (i=0; i<9; i++){
    neorv32_cpu_csr_write(CSR_MCYCLE, 0);
    sig_aprox_3(data_sw[i]);
    neorv32_cpu_csr_read(CSR_MCYCLE); 
  }
  // End
  neorv32_uart0_printf("END");
  #else
  uint32_t time_hw, time_sw7, time_sw5, time_sw3;
  int parte_entera_in, parte_decimal_in, parte_entera_out, parte_decimal_out;
  float fact_multi = 1000000000;
  float res;
  // Intro
  neorv32_uart0_printf("\n<<< SIGMOID through CFU compare with SIGMOID through software (with polynomial approximation computed by FPU) >>>\n");
  neorv32_uart0_printf("CFU R3-Type (rs1= 0xINPUT, rs2= DC, rd = OUT)\n");
  neorv32_uart0_printf("Since the FPU does not support division, a polynomial approximation of degree 3, 5 and 7 is made.\n");

  // Write 9 inputs to sigmoid and read the outputs one by one 
  neorv32_uart0_printf("\nThrough CFU hardware accelerator (CRI)\n");
  for (i=0; i<9 ; i++) {
    neorv32_uart0_printf("%u: neorv32_cfu_r3_instr( funct7=0b1111111, funct3=0b000, [rs1]=0x%x, [rs2]=0x%x ) = ", i, data_hw[i], 0);
    neorv32_uart0_printf("0x%x\n",neorv32_cfu_r3_instr(0b1111111, 0b000, data_hw[i], 0)); 
  } 
  neorv32_uart0_printf("\nApproximation with a degree 7 polynomial:\n\n");

  for (i=0; i<9 ; i++) {
    //In order to print the float via UART
    parte_entera_in = (int)data_sw[i];
    parte_decimal_in = (int)(fabs(riscv_intrinsic_fmuls(riscv_intrinsic_fsubs(data_sw[i], (float)parte_entera_in),fact_multi)));
    neorv32_uart0_printf("%u: f(%d.%d) = ", i, parte_entera_in, parte_decimal_in);
    res = sig_aprox_7(data_sw[i]);
    parte_entera_out = (int)res;
    parte_decimal_out = (int)(fabs(riscv_intrinsic_fmuls(riscv_intrinsic_fsubs(res, (float)parte_entera_out),fact_multi)));
    // In particular cases when the integer part is 0, and the number is negative, the sign must be managed
    if(n_sign_decimal(res) == 1){
        neorv32_uart0_printf("-%d.%d\n", parte_entera_out, parte_decimal_out);
    } else if (n_sign_decimal(res) == 2){
        neorv32_uart0_printf("-%d.0%d\n", parte_entera_out, parte_decimal_out);
    }else if (n_sign_decimal(res) == 3){
        neorv32_uart0_printf("%d.%d\n", parte_entera_out, parte_decimal_out);
    }else{
        neorv32_uart0_printf("%d.0%d\n", parte_entera_out, parte_decimal_out);
    }
  } 

  neorv32_uart0_printf("\nApproximation with a degree 5 polynomial:\n\n");

  for (i=0; i<9 ; i++) {
    //In order to print the float via UART
    parte_entera_in = (int)data_sw[i];
    parte_decimal_in = (int)(fabs(riscv_intrinsic_fmuls(riscv_intrinsic_fsubs(data_sw[i], (float)parte_entera_in),fact_multi)));
    neorv32_uart0_printf("%u: f(%d.%d) = ", i, parte_entera_in, parte_decimal_in);
    res = sig_aprox_5(data_sw[i]);
    parte_entera_out = (int)res;
    parte_decimal_out = (int)(fabs(riscv_intrinsic_fmuls(riscv_intrinsic_fsubs(res, (float)parte_entera_out),fact_multi)));
    // In particular cases when the integer part is 0, and the number is negative, the sign must be managed
    if(n_sign_decimal(res) == 1){
        neorv32_uart0_printf("-%d.%d\n", parte_entera_out, parte_decimal_out);
    } else if (n_sign_decimal(res) == 2){
        neorv32_uart0_printf("-%d.0%d\n", parte_entera_out, parte_decimal_out);
    }else if (n_sign_decimal(res) == 3){
        neorv32_uart0_printf("%d.%d\n", parte_entera_out, parte_decimal_out);
    }else{
        neorv32_uart0_printf("%d.0%d\n", parte_entera_out, parte_decimal_out);
    }
  } 

  neorv32_uart0_printf("\nApproximation with a degree 3 polynomial:\n\n");

  for (i=0; i<9 ; i++) {
    //In order to print the float via UART
    parte_entera_in = (int)data_sw[i];
    parte_decimal_in = (int)(fabs(riscv_intrinsic_fmuls(riscv_intrinsic_fsubs(data_sw[i], (float)parte_entera_in),fact_multi)));
    neorv32_uart0_printf("%u: f(%d.%d) = ", i, parte_entera_in, parte_decimal_in);
    res = sig_aprox_3(data_sw[i]);
    parte_entera_out = (int)res;
    parte_decimal_out = (int)(fabs(riscv_intrinsic_fmuls(riscv_intrinsic_fsubs(res, (float)parte_entera_out),fact_multi)));
    // In particular cases when the integer part is 0, and the number is negative, the sign must be managed
    if(n_sign_decimal(res) == 1){
        neorv32_uart0_printf("-%d.%d\n", parte_entera_out, parte_decimal_out);
    } else if (n_sign_decimal(res) == 2){
        neorv32_uart0_printf("-%d.0%d\n", parte_entera_out, parte_decimal_out);
    }else if (n_sign_decimal(res) == 3){
        neorv32_uart0_printf("%d.%d\n", parte_entera_out, parte_decimal_out);
    }else{
        neorv32_uart0_printf("%d.0%d\n", parte_entera_out, parte_decimal_out);
    }
  }

  neorv32_uart0_printf("\nMeasure the lartency of all methods\n");
  neorv32_uart0_printf("\nThe test performs the calculation for 9 input data\n\n");

  neorv32_cpu_csr_write(CSR_MCYCLE, 0); // start timing
  for (i=0; i<9 ; i++) {
    neorv32_cfu_r3_instr(0b1111111, 0b000, data_hw[i], 0);
  } 
  time_hw = neorv32_cpu_csr_read(CSR_MCYCLE); // stop timing

  neorv32_cpu_csr_write(CSR_MCYCLE, 0); // start timing
  for (i=0; i<9 ; i++) {
    sig_aprox_7(data_sw[i]);
  } 
  time_sw7 = neorv32_cpu_csr_read(CSR_MCYCLE); // stop timing

  neorv32_cpu_csr_write(CSR_MCYCLE, 0); // start timing
  for (i=0; i<9 ; i++) {
    sig_aprox_5(data_sw[i]);
  } 
  time_sw5 = neorv32_cpu_csr_read(CSR_MCYCLE); // stop timing

  neorv32_cpu_csr_write(CSR_MCYCLE, 0); // start timing
  for (i=0; i<9 ; i++) {
    sig_aprox_3(data_sw[i]);
  } 
  time_sw3 = neorv32_cpu_csr_read(CSR_MCYCLE); // stop timing

  neorv32_uart0_printf("HW calculated through SIG(CRI) = %u cycles\n", time_hw);
  neorv32_uart0_printf("SW aprox by polynomial grade 7 via FPU = %u cycles\n", time_sw7);
  neorv32_uart0_printf("SW aprox by polynomial grade 5 via FPU = %u cycles\n", time_sw5);
  neorv32_uart0_printf("SW aprox by polynomial grade 3 via FPU = %u cycles\n", time_sw3);
  // End
  neorv32_uart0_printf("\nProgram completed.\n");
  #endif

  return 0;
}
\end{minted}
\caption{Compración cálculo de la sigmoide: CRI vs FPU; main.c}
\label{ap-cod:27}
\end{code}
